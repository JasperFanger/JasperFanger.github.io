<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JASPER_FONS</title>
  
  
  <link href="http://jasperfanger.github.io/atom.xml" rel="self"/>
  
  <link href="http://jasperfanger.github.io/"/>
  <updated>2024-09-12T10:07:10.219Z</updated>
  <id>http://jasperfanger.github.io/</id>
  
  <author>
    <name>JASPER_FONS</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://jasperfanger.github.io/posts/0.html"/>
    <id>http://jasperfanger.github.io/posts/0.html</id>
    <published>2024-09-12T10:04:47.648Z</published>
    <updated>2024-09-12T10:07:10.219Z</updated>
    
    <content type="html"><![CDATA[<h3 id="完整的源代码、逐行分析及调用示例">完整的源代码、逐行分析及调用示例</h3><h4 id="源代码：4阶IIR滤波器实现">源代码：4阶IIR滤波器实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">float</span> <span class="type">flt32_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">IirFilter4thCoef_</span> &#123;</span></span><br><span class="line">    <span class="type">flt32_t</span> B[<span class="number">5</span>];  <span class="comment">// 前馈系数 (B0, B1, B2, B3, B4)</span></span><br><span class="line">    <span class="type">flt32_t</span> A[<span class="number">5</span>];  <span class="comment">// 反馈系数 (A0, A1, A2, A3, A4)</span></span><br><span class="line">&#125; IirFilter4thCoef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">IirFilter4th_</span> &#123;</span></span><br><span class="line">    <span class="type">flt32_t</span> x_delay[<span class="number">4</span>];  <span class="comment">// 延迟输入 (x[n-1], x[n-2], x[n-3], x[n-4])</span></span><br><span class="line">    <span class="type">flt32_t</span> y_delay[<span class="number">4</span>];  <span class="comment">// 延迟输出 (y[n-1], y[n-2], y[n-3], y[n-4])</span></span><br><span class="line">&#125; IirFilter4th;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">flt32_t</span> <span class="title function_">IirFilter4th_Proc</span><span class="params">(<span class="type">flt32_t</span> input, <span class="type">const</span> IirFilter4thCoef *coef, IirFilter4th *filter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">flt32_t</span> output;  <span class="comment">// 输出</span></span><br><span class="line">    <span class="type">flt32_t</span> bx = coef-&gt;B[<span class="number">0</span>] * input;  <span class="comment">// 计算前馈部分</span></span><br><span class="line">    <span class="type">flt32_t</span> ay = <span class="number">0.f</span>;  <span class="comment">// 反馈部分初始化为0</span></span><br><span class="line">    <span class="type">int16_t</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算前馈和反馈部分</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bx += coef-&gt;B[i + <span class="number">1</span>] * filter-&gt;x_delay[i];  <span class="comment">// 前馈项：过去输入的加权和</span></span><br><span class="line">        ay += coef-&gt;A[i + <span class="number">1</span>] * filter-&gt;y_delay[i];  <span class="comment">// 反馈项：过去输出的加权和</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    output = (bx - ay) / coef-&gt;A[<span class="number">0</span>];  <span class="comment">// 输出结果为前馈部分减去反馈部分，再除以A[0]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新延迟数组，将新输入和新输出插入</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">3</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        filter-&gt;x_delay[i] = filter-&gt;x_delay[i - <span class="number">1</span>];  <span class="comment">// 延迟输入更新</span></span><br><span class="line">        filter-&gt;y_delay[i] = filter-&gt;y_delay[i - <span class="number">1</span>];  <span class="comment">// 延迟输出更新</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    filter-&gt;x_delay[<span class="number">0</span>] = input;   <span class="comment">// 当前输入保存到x_delay[0]</span></span><br><span class="line">    filter-&gt;y_delay[<span class="number">0</span>] = output;  <span class="comment">// 当前输出保存到y_delay[0]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output;  <span class="comment">// 返回滤波后的输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码逐行分析：">代码逐行分析：</h3><h4 id="结构体定义">结构体定义</h4><ol><li><p><strong><code>IirFilter4thCoef</code></strong> 结构体定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">IirFilter4thCoef_</span> &#123;</span></span><br><span class="line">    <span class="type">flt32_t</span> B[<span class="number">5</span>];</span><br><span class="line">    <span class="type">flt32_t</span> A[<span class="number">5</span>];</span><br><span class="line">&#125; IirFilter4thCoef;</span><br></pre></td></tr></table></figure><ul><li><code>B[5]</code> 和 <code>A[5]</code> 分别表示IIR滤波器的前馈（feedforward）和反馈（feedback）系数。滤波器的输出由这两个系数控制。</li></ul></li><li><p><strong><code>IirFilter4th</code></strong> 结构体定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">IirFilter4th_</span> &#123;</span></span><br><span class="line">    <span class="type">flt32_t</span> x_delay[<span class="number">4</span>];  <span class="comment">// 前四个输入的延迟</span></span><br><span class="line">    <span class="type">flt32_t</span> y_delay[<span class="number">4</span>];  <span class="comment">// 前四个输出的延迟</span></span><br><span class="line">&#125; IirFilter4th;</span><br></pre></td></tr></table></figure><ul><li><code>x_delay[4]</code> 和 <code>y_delay[4]</code> 存储最近4个输入和输出的延迟值，帮助计算当前输出。</li></ul></li></ol><h4 id="函数-IirFilter4th-Proc-的实现：">函数 <code>IirFilter4th_Proc</code> 的实现：</h4>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">flt32_t</span> <span class="title function_">IirFilter4th_Proc</span><span class="params">(<span class="type">flt32_t</span> input, <span class="type">const</span> IirFilter4thCoef *coef, IirFilter4th *filter)</span></span><br></pre></td></tr></table></figure><ul><li><strong>输入参数</strong>：<ul><li><code>input</code>：当前输入的信号值。</li><li><code>coef</code>：指向存储滤波器前馈和反馈系数的结构体的指针。</li><li><code>filter</code>：指向滤波器的状态（延迟输入和输出）的指针。</li></ul></li></ul><ol><li><p><strong>初始化变量</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">flt32_t</span> output;</span><br><span class="line"><span class="type">flt32_t</span> bx = coef-&gt;B[<span class="number">0</span>] * input;  <span class="comment">// 前馈计算从B[0] * input开始</span></span><br><span class="line"><span class="type">flt32_t</span> ay = <span class="number">0.f</span>;  <span class="comment">// 反馈部分初始值</span></span><br></pre></td></tr></table></figure><ul><li><code>bx</code> 是前馈部分的初始值，由当前输入乘以系数 <code>B[0]</code> 计算。</li><li><code>ay</code> 是反馈部分，初始为0，用于存储反馈项的计算结果。</li></ul></li><li><p><strong>计算前馈和反馈部分</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    bx += coef-&gt;B[i + <span class="number">1</span>] * filter-&gt;x_delay[i];  <span class="comment">// 前馈项</span></span><br><span class="line">    ay += coef-&gt;A[i + <span class="number">1</span>] * filter-&gt;y_delay[i];  <span class="comment">// 反馈项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>该循环对先前的4个输入 (<code>x_delay</code>) 和输出 (<code>y_delay</code>) 进行处理：<ul><li><code>bx</code> 累加过去的输入值乘以前馈系数 <code>B[i+1]</code>。</li><li><code>ay</code> 累加过去的输出值乘以反馈系数 <code>A[i+1]</code>。</li></ul></li></ul></li><li><p><strong>计算输出</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output = (bx - ay) / coef-&gt;A[<span class="number">0</span>];  <span class="comment">// 前馈 - 反馈 / A[0]</span></span><br></pre></td></tr></table></figure><ul><li>输出值是前馈项减去反馈项，再除以 <code>A[0]</code>，这符合IIR滤波器的标准公式。</li></ul></li><li><p><strong>更新延迟缓冲区</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">3</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">    filter-&gt;x_delay[i] = filter-&gt;x_delay[i - <span class="number">1</span>];  <span class="comment">// 更新x延迟</span></span><br><span class="line">    filter-&gt;y_delay[i] = filter-&gt;y_delay[i - <span class="number">1</span>];  <span class="comment">// 更新y延迟</span></span><br><span class="line">&#125;</span><br><span class="line">filter-&gt;x_delay[<span class="number">0</span>] = input;    <span class="comment">// 当前输入保存为最新延迟</span></span><br><span class="line">filter-&gt;y_delay[<span class="number">0</span>] = output;   <span class="comment">// 当前输出保存为最新延迟</span></span><br></pre></td></tr></table></figure><ul><li>延迟缓冲区的元素依次向后移动，以保持滤波器的状态。当前输入和输出被放置在缓冲区的最前面 (<code>x_delay[0]</code> 和 <code>y_delay[0]</code>)。</li></ul></li><li><p><strong>返回输出</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> output;  <span class="comment">// 返回当前滤波后的输出</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="函数调用示例：">函数调用示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 定义滤波器系数</span></span><br><span class="line">    IirFilter4thCoef coef = &#123;</span><br><span class="line">        .B = &#123;<span class="number">0.1f</span>, <span class="number">0.15f</span>, <span class="number">0.15f</span>, <span class="number">0.1f</span>, <span class="number">0.05f</span>&#125;,  <span class="comment">// 前馈系数</span></span><br><span class="line">        .A = &#123;<span class="number">1.0f</span>, <span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.4f</span>, <span class="number">0.1f</span>&#125;     <span class="comment">// 反馈系数</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化滤波器状态（延迟输入和输出）</span></span><br><span class="line">    IirFilter4th filter = &#123;</span><br><span class="line">        .x_delay = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,  <span class="comment">// 初始输入延迟为0</span></span><br><span class="line">        .y_delay = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;   <span class="comment">// 初始输出延迟为0</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入信号序列</span></span><br><span class="line">    <span class="type">flt32_t</span> input_signal[] = &#123;<span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(input_signal) / <span class="keyword">sizeof</span>(input_signal[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 滤波后的输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">flt32_t</span> output = IirFilter4th_Proc(input_signal[i], &amp;coef, &amp;filter);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input: %.2f, Output: %.2f\n&quot;</span>, input_signal[i], output);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行示例输出：">运行示例输出：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:  1.00, Output:  0.10</span><br><span class="line">Input:  0.50, Output:  0.18</span><br><span class="line">Input: -0.50, Output:  0.11</span><br><span class="line">Input: -1.00, Output: -0.12</span><br><span class="line">Input:  0.00, Output: -0.22</span><br></pre></td></tr></table></figure><h3 id="总结：">总结：</h3><ul><li><strong>结构体 <code>IirFilter4thCoef</code></strong>：保存了4阶IIR滤波器的前馈系数（<code>B[5]</code>）和反馈系数（<code>A[5]</code>）。</li><li><strong>结构体 <code>IirFilter4th</code></strong>：保存了滤波器的状态，即最近4个输入（<code>x_delay[4]</code>）和输出（<code>y_delay[4]</code>）。</li><li><strong><code>IirFilter4th_Proc</code> 函数</strong>：处理每一个输入样本，通过递归的方式结合过去的输入和输出计算当前的输出，并更新滤波器的状态。</li></ul><p>通过该实现，您可以对输入信号进行4阶IIR滤波。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;完整的源代码、逐行分析及调用示例&quot;&gt;完整的源代码、逐行分析及调用示例&lt;/h3&gt;
&lt;h4 id=&quot;源代码：4阶IIR滤波器实现&quot;&gt;源代码：4阶IIR滤波器实现&lt;/h4&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>固定翼气动模型-气动力矩</title>
    <link href="http://jasperfanger.github.io/posts/21bd7246.html"/>
    <id>http://jasperfanger.github.io/posts/21bd7246.html</id>
    <published>2024-09-12T09:54:34.883Z</published>
    <updated>2024-09-12T10:00:00.016Z</updated>
    
    
    
    
    <category term="Study" scheme="http://jasperfanger.github.io/categories/Study/"/>
    
    <category term="Aircraft" scheme="http://jasperfanger.github.io/categories/Study/Aircraft/"/>
    
    
    <category term="Aircraft" scheme="http://jasperfanger.github.io/tags/Aircraft/"/>
    
  </entry>
  
  <entry>
    <title>Some useful things</title>
    <link href="http://jasperfanger.github.io/posts/59c3ed0.html"/>
    <id>http://jasperfanger.github.io/posts/59c3ed0.html</id>
    <published>2024-09-12T09:54:34.882Z</published>
    <updated>2024-09-12T10:00:00.015Z</updated>
    
    <content type="html"><![CDATA[<hr><p>Tools</p><table><thead><tr><th>用途</th><th>地址</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td>图床</td><td><a href="https://picui.cn/user/dashboard">仪表盘 (picui.cn)</a></td><td style="text-align:center"></td></tr><tr><td>latex 表格生成</td><td><a href="https://www.tablesgenerator.com/#">Create LaTeX tables online – TablesGenerator.com</a></td><td style="text-align:center"></td></tr><tr><td>TCP</td><td><a href="http://tcp.xnkiot.com/">TCP服务端测试工具 (xnkiot.com)</a></td><td style="text-align:center"></td></tr><tr><td>GPT-api</td><td><a href="https://23tymo.aitianhu1.top/#/chat/1723776148972">AItianhu (aitianhu1.top)</a></td><td style="text-align:center"></td></tr><tr><td>文献下载</td><td><a href="http://lib.qboshi.net/">个人中心 - 【Q博士图书馆】 简约纯净的文献下载站 (qboshi.net)</a></td><td style="text-align:center"></td></tr><tr><td></td><td></td><td style="text-align:center"></td></tr><tr><td></td><td></td><td style="text-align:center"></td></tr></tbody></table><hr><p>Study &amp; Review</p><table><thead><tr><th>课程</th><th>地址</th><th>备注</th></tr></thead><tbody><tr><td></td><td><a href="https://bohrium.dp.tech/courses/1312856407?tab=courses">数学要素｜鸢尾花书：从加减乘除到机器学习 - Bohrium (dp.tech)</a></td><td></td></tr><tr><td></td><td><a href="https://iot-book.github.io/">物联网前沿实践 - 清华大学 - 王继良 (iot-book.github.io)</a></td><td></td></tr><tr><td></td><td><a href="https://hexo.fluid-dev.com/docs/start/">Hexo Fluid 用户手册 (fluid-dev.com)</a></td><td></td></tr><tr><td></td><td><a href="https://bohrium.dp.tech/courses/5851299296/content?file=1393">Python语言基础与应用 - Bohrium (dp.tech)</a></td><td></td></tr><tr><td></td><td><a href="https://bohrium.dp.tech/courses/2746838734/content?file=6089">Zotero基础教程 - Bohrium (dp.tech)</a></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;Tools&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;th&gt;地址&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;图床&lt;/td&gt;</summary>
      
    
    
    
    <category term="Study" scheme="http://jasperfanger.github.io/categories/Study/"/>
    
    <category term="Review" scheme="http://jasperfanger.github.io/categories/Study/Review/"/>
    
    
    <category term="Review" scheme="http://jasperfanger.github.io/tags/Review/"/>
    
  </entry>
  
  <entry>
    <title>HTML中自定义网页内容</title>
    <link href="http://jasperfanger.github.io/posts/2930b549.html"/>
    <id>http://jasperfanger.github.io/posts/2930b549.html</id>
    <published>2024-09-09T12:14:59.000Z</published>
    <updated>2024-09-12T10:00:00.016Z</updated>
    
    <content type="html"><![CDATA[<h1>HTML中自定义网页内容</h1><p>可以通过HTML结构、CSS样式和JavaScript交互来自定义网页内容。下面是一个示例，展示如何创建一个简单的自定义网页：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>自定义网页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用CSS进行样式设计 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-family</span>: <span class="string">&#x27;Microsoft Yahei&#x27;</span>, sans-serif;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#f7f7f7</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">header</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#008cba</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">15px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">24px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.content</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.card</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: white;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">2px</span> <span class="number">5px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.1</span>);</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.button</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#008cba</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: none;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">cursor</span>: pointer;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">16px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.button</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#005f73</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 顶部导航栏 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    欢迎来到我的自定义网页</span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 主要内容区域 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 卡片1：介绍 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>介绍<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个简单的网页示例，展示了如何使用HTML和CSS自定义网页内容。你可以根据需求修改样式和功能。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 卡片2：功能特性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>功能特性<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>响应式设计<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>自定义CSS样式<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>简单的JavaScript交互<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 卡片3：按钮交互 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>点击按钮<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;displayMessage()&quot;</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;message&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: 15px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- JavaScript交互逻辑 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">displayMessage</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;message&quot;</span>).<span class="property">innerText</span> = <span class="string">&quot;你点击了按钮！&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="解释：">解释：</h3><ol><li><strong>HTML结构</strong>：页面包含一个导航栏和几个卡片内容区域，用于展示不同的网页内容。</li><li><strong>CSS样式</strong>：设置了页面的背景颜色、字体样式、卡片布局等，按钮带有悬停（hover）效果。</li><li><strong>JavaScript交互</strong>：一个简单的函数 <code>displayMessage()</code>，当按钮被点击时，会在页面中显示消息。</li></ol><h3 id="自定义扩展：">自定义扩展：</h3><ul><li>修改CSS中的颜色、字体大小或边距，以调整页面风格。</li><li>增加更多HTML元素，如图片 <code>&lt;img&gt;</code>、表单 <code>&lt;form&gt;</code>等，扩展功能。</li><li>使用JavaScript添加更多动态交互，比如数据表单提交、动画效果等。</li></ul><p>这为创建更复杂的网页提供了基础，方便你根据具体需求进行进一步定制和扩展。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;HTML中自定义网页内容&lt;/h1&gt;
&lt;p&gt;可以通过HTML结构、CSS样式和JavaScript交互来自定义网页内容。下面是一个示例，展示如何创建一个简单的自定义网页：&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c</summary>
      
    
    
    
    <category term="Study" scheme="http://jasperfanger.github.io/categories/Study/"/>
    
    <category term="HTML" scheme="http://jasperfanger.github.io/categories/Study/HTML/"/>
    
    
    <category term="HTML" scheme="http://jasperfanger.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>【C++】 虚函数</title>
    <link href="http://jasperfanger.github.io/posts/460845ae.html"/>
    <id>http://jasperfanger.github.io/posts/460845ae.html</id>
    <published>2024-09-03T02:54:41.000Z</published>
    <updated>2024-09-12T10:00:00.014Z</updated>
    
    <content type="html"><![CDATA[<p>在 C++ 中，<strong>虚函数</strong>（Virtual Function）是一种用于实现多态性的成员函数。通过将一个函数声明为虚函数，基类可以允许派生类重写该函数，并在运行时根据对象的实际类型调用适当的函数版本，而不是编译时确定的函数版本。</p><h3 id="虚函数的关键点">虚函数的关键点</h3><ol><li><p><strong>多态性</strong>：</p><ul><li>虚函数是实现<strong>运行时多态性</strong>的关键工具。多态性允许同一个接口（即同样的函数调用）根据不同的对象类型表现出不同的行为。</li></ul></li><li><p><strong>基类和派生类</strong>：</p><ul><li>当在基类中声明一个虚函数时，派生类可以重新定义（覆盖）该函数。这种覆盖允许通过基类指针或引用调用派生类的实现。</li></ul></li><li><p><strong>虚函数表（VTable）</strong>：</p><ul><li>当一个类包含虚函数时，编译器会为这个类生成一个<strong>虚函数表</strong>（VTable），其中包含指向虚函数的指针。每个对象都包含一个指向该虚函数表的指针（通常称为 vptr）。在运行时，C++ 会根据这个虚函数表来决定调用哪个函数。</li></ul></li><li><p><strong><code>virtual</code> 关键字</strong>：</p><ul><li>在基类中，通过 <code>virtual</code> 关键字来声明虚函数。派生类可以覆盖这个函数，而无需再次使用 <code>virtual</code> 关键字。</li></ul></li></ol><h3 id="示例代码">示例代码</h3><p>以下是一个简单的虚函数示例，展示了如何实现多态性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 基类中的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal makes a sound&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 派生类覆盖虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Dog barks&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 派生类覆盖虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Cat meows&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Animal* animal1 = <span class="keyword">new</span> <span class="built_in">Dog</span>(); <span class="comment">// 基类指针指向派生类对象</span></span><br><span class="line">    Animal* animal2 = <span class="keyword">new</span> <span class="built_in">Cat</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基类指针调用虚函数，运行时多态性生效</span></span><br><span class="line">    animal1-&gt;<span class="built_in">makeSound</span>(); <span class="comment">// 输出：Dog barks</span></span><br><span class="line">    animal2-&gt;<span class="built_in">makeSound</span>(); <span class="comment">// 输出：Cat meows</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理内存</span></span><br><span class="line">    <span class="keyword">delete</span> animal1;</span><br><span class="line">    <span class="keyword">delete</span> animal2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解释">解释</h3><ul><li><strong>虚函数声明</strong>：在 <code>Animal</code> 类中，<code>makeSound()</code> 函数被声明为虚函数（<code>virtual</code>）。</li><li><strong>函数覆盖</strong>：<code>Dog</code> 和 <code>Cat</code> 类都覆盖了基类的 <code>makeSound()</code> 函数。</li><li><strong>多态性</strong>：在 <code>main()</code> 函数中，尽管 <code>animal1</code> 和 <code>animal2</code> 都是 <code>Animal</code> 类型的指针，但由于虚函数的存在，它们在运行时调用了各自对象的 <code>makeSound()</code> 实现。</li></ul><h3 id="虚函数的重要性">虚函数的重要性</h3><ol><li><p><strong>实现多态性</strong>：虚函数是 C++ 实现运行时多态性的核心机制。通过虚函数，程序可以在运行时根据对象的实际类型决定调用哪个函数版本。</p></li><li><p><strong>动态绑定</strong>：虚函数使得 C++ 支持动态绑定（又称为后期绑定或运行时绑定），即在程序运行时而不是编译时确定调用哪个函数。</p></li><li><p><strong>接口设计</strong>：在设计基类时，通过虚函数可以定义一个通用接口，而派生类可以通过覆盖这些虚函数来实现特定的行为。这使得代码更具灵活性和可扩展性。</p></li></ol><h3 id="纯虚函数与抽象类">纯虚函数与抽象类</h3><ul><li><p>如果一个虚函数在基类中没有实现，而是希望所有派生类都必须提供自己的实现，可以将该虚函数声明为<strong>纯虚函数</strong>（Pure Virtual Function）。纯虚函数的声明形式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p>包含纯虚函数的类称为<strong>抽象类</strong>（Abstract Class），不能实例化对象，只能作为基类被继承。</p></li></ul><h3 id="小结">小结</h3><ul><li><strong>虚函数</strong> 使得 C++ 能够实现运行时多态性，允许基类定义通用接口，而派生类可以根据需要覆盖和实现这些接口。</li><li>使用虚函数可以通过基类指针或引用调用派生类的函数，从而使代码更加灵活和可扩展。</li></ul><p>在这段代码中，我们展示了C++中虚函数如何实现运行时的多态性。让我们逐行分析一下代码的关键部分：</p><h3 id="代码解析">代码解析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Animal* animal1 = <span class="keyword">new</span> <span class="built_in">Dog</span>(); <span class="comment">// 基类指针指向派生类对象</span></span><br><span class="line">    Animal* animal2 = <span class="keyword">new</span> <span class="built_in">Cat</span>();</span><br></pre></td></tr></table></figure><ul><li><strong>基类指针指向派生类对象</strong>：这里我们创建了两个基类 <code>Animal</code> 的指针 <code>animal1</code> 和 <code>animal2</code>，并分别让它们指向 <code>Dog</code> 和 <code>Cat</code> 的对象。这种做法是多态性的基础，因为它允许我们使用基类指针来引用派生类对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类指针调用虚函数，运行时多态性生效</span></span><br><span class="line">animal1-&gt;<span class="built_in">makeSound</span>(); <span class="comment">// 输出：Dog barks</span></span><br><span class="line">animal2-&gt;<span class="built_in">makeSound</span>(); <span class="comment">// 输出：Cat meows</span></span><br></pre></td></tr></table></figure><ul><li><strong>调用虚函数</strong>：尽管 <code>animal1</code> 和 <code>animal2</code> 的类型都是 <code>Animal*</code>，但是由于 <code>makeSound()</code> 是一个虚函数，实际调用的函数版本在运行时根据对象的实际类型（<code>Dog</code> 和 <code>Cat</code>）来决定。<ul><li><code>animal1-&gt;makeSound();</code> 调用 <code>Dog</code> 类的 <code>makeSound()</code> 方法，输出 “Dog barks”。</li><li><code>animal2-&gt;makeSound();</code> 调用 <code>Cat</code> 类的 <code>makeSound()</code> 方法，输出 “Cat meows”。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 清理内存</span></span><br><span class="line">    <span class="keyword">delete</span> animal1;</span><br><span class="line">    <span class="keyword">delete</span> animal2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>清理内存</strong>：在 C++ 中，使用 <code>new</code> 动态分配的内存需要使用 <code>delete</code> 来释放。这里我们在程序结束前删除了 <code>animal1</code> 和 <code>animal2</code> 所指向的对象，以防止内存泄漏。</li></ul><h3 id="总结">总结</h3><ul><li><strong>多态性</strong>：通过虚函数机制，基类指针 <code>Animal*</code> 能够调用派生类 <code>Dog</code> 和 <code>Cat</code> 的 <code>makeSound()</code> 方法，展示了多态性。</li><li><strong>运行时决策</strong>：在运行时，C++ 根据指针实际指向的对象类型来决定调用哪个函数，这就是动态绑定或后期绑定的核心。</li></ul><p>这个示例很好地展示了C++中虚函数和多态性如何使得代码更加灵活和可扩展。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 C++ 中，&lt;strong&gt;虚函数&lt;/strong&gt;（Virtual Function）是一种用于实现多态性的成员函数。通过将一个函数声明为虚函数，基类可以允许派生类重写该函数，并在运行时根据对象的实际类型调用适当的函数版本，而不是编译时确定的函数版本。&lt;/p&gt;
&lt;h3</summary>
      
    
    
    
    <category term="Study" scheme="http://jasperfanger.github.io/categories/Study/"/>
    
    <category term="C++" scheme="http://jasperfanger.github.io/categories/Study/C/"/>
    
    
    <category term="C++" scheme="http://jasperfanger.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【Qt】  qmake和cmake区别</title>
    <link href="http://jasperfanger.github.io/posts/a121dc4.html"/>
    <id>http://jasperfanger.github.io/posts/a121dc4.html</id>
    <published>2024-09-03T02:54:41.000Z</published>
    <updated>2024-09-12T10:00:00.015Z</updated>
    
    <content type="html"><![CDATA[<p>在 Qt 开发中，<strong>qmake</strong> 和 <strong>CMake</strong> 是两种常用的构建工具，它们用于配置和管理项目的构建过程。虽然两者可以用于类似的目的，但它们有不同的设计哲学、使用场景和特性。以下是它们之间的主要区别：</p><h3 id="1-工具的来源和默认支持">1. <strong>工具的来源和默认支持</strong></h3><ul><li><p><strong>qmake</strong>:</p><ul><li><strong>来源</strong>: qmake 是由 Qt 项目自带的构建系统生成器，专门为 Qt 应用程序的构建而设计。</li><li><strong>默认支持</strong>: qmake 是 Qt 项目的默认构建工具，尤其适合小型和中型的纯 Qt 项目。它自动支持 Qt 的特性，如翻译、资源文件、MOC（Meta-Object Compiler）等。</li></ul></li><li><p><strong>CMake</strong>:</p><ul><li><strong>来源</strong>: CMake 是一个通用的跨平台构建系统生成器，可以生成用于构建项目的原生构建脚本（如 Makefile、Visual Studio 项目文件等）。</li><li><strong>默认支持</strong>: CMake 是一个更通用的工具，支持多种编程语言和构建工具。虽然 CMake 不是 Qt 的原生工具，但它已被广泛接受并且现在完全支持 Qt 项目的构建。</li></ul></li></ul><h3 id="2-配置文件">2. <strong>配置文件</strong></h3><ul><li><p><strong>qmake</strong>:</p><ul><li><strong>配置文件</strong>: qmake 使用 <code>.pro</code> 文件（项目文件）来配置项目的构建。这些文件相对简单，适合快速配置和管理 Qt 项目。</li><li><strong>语法</strong>: <code>.pro</code> 文件使用特定的 qmake 语法，设计简单且直接，主要针对 Qt 的特性进行优化。</li></ul><p>示例 <code>.pro</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QT += core gui</span><br><span class="line">TARGET = myapp</span><br><span class="line">TEMPLATE = app</span><br><span class="line">SOURCES += main.cpp mainwindow.cpp</span><br><span class="line">HEADERS += mainwindow.h</span><br></pre></td></tr></table></figure></li><li><p><strong>CMake</strong>:</p><ul><li><strong>配置文件</strong>: CMake 使用 <code>CMakeLists.txt</code> 文件来配置项目的构建。这些文件可以描述更复杂的构建逻辑，并且适用于大型项目。</li><li><strong>语法</strong>: CMake 的语法更复杂、更强大，允许定义条件、函数、宏等，适用于复杂和跨平台的项目配置。</li></ul><p>示例 <code>CMakeLists.txt</code> 文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(MyApp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(Qt5 COMPONENTS Core Gui REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(myapp main.cpp mainwindow.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(myapp Qt5::Core Qt5::Gui)</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-功能特性和灵活性">3. <strong>功能特性和灵活性</strong></h3><ul><li><p><strong>qmake</strong>:</p><ul><li><strong>特性</strong>: qmake 专门为 Qt 项目定制，因此在处理 Qt 特性（如 MOC、UIC、RCC）时非常方便。它的配置文件通常较为简单，适合快速原型开发。</li><li><strong>灵活性</strong>: qmake 的灵活性较有限，适合中小型项目。对于需要复杂构建逻辑或跨平台支持的大型项目，它可能不如 CMake 灵活。</li></ul></li><li><p><strong>CMake</strong>:</p><ul><li><strong>特性</strong>: CMake 是一个更通用的构建系统，适用于各种语言和项目类型。它提供了丰富的模块和功能，适合处理复杂的依赖关系和自定义构建步骤。</li><li><strong>灵活性</strong>: CMake 非常灵活，可以用于跨平台项目，支持条件编译、跨编译等高级功能，适合大型项目或需要与其他构建系统集成的场景。</li></ul></li></ul><h3 id="4-跨平台支持和生态系统">4. <strong>跨平台支持和生态系统</strong></h3><ul><li><p><strong>qmake</strong>:</p><ul><li><strong>跨平台</strong>: 虽然 qmake 支持跨平台构建，但它主要为 Qt 项目优化，不如 CMake 灵活。</li><li><strong>生态系统</strong>: qmake 是 Qt 的专用工具，生态系统主要围绕 Qt 展开，其他语言或工具的支持有限。</li></ul></li><li><p><strong>CMake</strong>:</p><ul><li><strong>跨平台</strong>: CMake 是一个真正的跨平台构建工具，可以生成 Windows、macOS、Linux 等平台的构建文件，甚至可以生成 Android 和 iOS 项目的构建文件。</li><li><strong>生态系统</strong>: CMake 拥有庞大的生态系统，支持广泛的第三方库和工具，并且可以与几乎所有流行的构建系统集成。</li></ul></li></ul><h3 id="5-学习曲线和社区支持">5. <strong>学习曲线和社区支持</strong></h3><ul><li><p><strong>qmake</strong>:</p><ul><li><strong>学习曲线</strong>: 对于熟悉 Qt 的开发者来说，qmake 很容易上手。它的配置文件简单直接，适合快速开发。</li><li><strong>社区支持</strong>: 由于是 Qt 的官方工具，qmake 有良好的社区支持，但范围主要限于 Qt 社区。</li></ul></li><li><p><strong>CMake</strong>:</p><ul><li><strong>学习曲线</strong>: CMake 的学习曲线较陡，因为它提供了更多的功能和更复杂的语法。对于初学者来说，掌握 CMake 可能需要更多的时间。</li><li><strong>社区支持</strong>: CMake 拥有庞大的用户群体和社区支持，涵盖了各种编程语言和开发平台。</li></ul></li></ul><h3 id="总结">总结</h3><ul><li><p><strong>qmake</strong>：适合中小型的纯 Qt 项目，尤其是在需要快速开发原型或对 Qt 特性有较多依赖的情况下。qmake 简单易用，但在处理复杂项目时可能显得不够灵活。</p></li><li><p><strong>CMake</strong>：适合需要高度灵活性、复杂构建逻辑、跨平台支持的大型项目。CMake 功能强大，可以与广泛的工具和库集成，尽管学习曲线较陡，但它提供了更大的自由度和可扩展性。</p></li></ul><p>选择 qmake 还是 CMake 取决于项目的规模、复杂性和特定需求。如果你开发的是一个小型或中型的纯 Qt 项目，qmake 是一个很好的选择。如果你需要跨平台支持或处理更复杂的项目，CMake 可能是更好的选择。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Qt 开发中，&lt;strong&gt;qmake&lt;/strong&gt; 和 &lt;strong&gt;CMake&lt;/strong&gt; 是两种常用的构建工具，它们用于配置和管理项目的构建过程。虽然两者可以用于类似的目的，但它们有不同的设计哲学、使用场景和特性。以下是它们之间的主要区别：&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Study" scheme="http://jasperfanger.github.io/categories/Study/"/>
    
    <category term="Qt" scheme="http://jasperfanger.github.io/categories/Study/Qt/"/>
    
    
    <category term="Qt" scheme="http://jasperfanger.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>【C++】 箭头操作符</title>
    <link href="http://jasperfanger.github.io/posts/bcf3ee3e.html"/>
    <id>http://jasperfanger.github.io/posts/bcf3ee3e.html</id>
    <published>2024-09-02T02:54:41.000Z</published>
    <updated>2024-09-12T10:00:00.014Z</updated>
    
    <content type="html"><![CDATA[<p>在C++中，<code>-&gt;</code> 操作符通常被称为<strong>箭头操作符</strong>（Arrow Operator）或<strong>成员访问运算符通过指针</strong>（Member Access Operator via Pointer）。这个名称来源于它的形状和功能，即通过指针访问对象的成员（包括成员变量和成员函数）。</p><h3 id="常见称呼">常见称呼</h3><ul><li><strong>箭头操作符</strong>（Arrow Operator）：这个名称非常直观，因为它的形状就像一个箭头。</li><li><strong>成员访问运算符通过指针</strong>（Member Access Operator via Pointer）：这个名称更加正式，描述了它的功能，即通过指针来访问对象的成员。</li></ul><p>在日常讨论中，开发者通常会使用“箭头操作符”这个简称，因为它简单明了，容易理解。</p><p>在C++中，箭头操作符 <code>-&gt;</code> 是用于通过指针访问对象的成员（包括成员变量和成员函数）。与点操作符 <code>.</code> 不同，点操作符用于直接访问对象的成员，而箭头操作符 <code>-&gt;</code> 则用于指向对象的指针。</p><h3 id="使用场景和示例">使用场景和示例</h3><ol><li><p><strong>访问对象的成员变量</strong>：如果你有一个指向对象的指针，你可以使用 <code>-&gt;</code> 来访问该对象的成员变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;      <span class="comment">// 创建对象</span></span><br><span class="line">    obj.value = <span class="number">10</span>;   <span class="comment">// 使用点操作符访问成员变量</span></span><br><span class="line"></span><br><span class="line">    MyClass* ptr = &amp;obj;  <span class="comment">// 创建指向对象的指针</span></span><br><span class="line">    ptr-&gt;value = <span class="number">20</span>;      <span class="comment">// 使用箭头操作符访问成员变量</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj.value: &quot;</span> &lt;&lt; obj.value &lt;&lt; std::endl; <span class="comment">// 输出：20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>ptr-&gt;value</code> 等同于 <code>(*ptr).value</code>，但 <code>-&gt;</code> 语法更加简洁和直观。</p></li><li><p><strong>调用对象的成员函数</strong>：你也可以使用 <code>-&gt;</code> 来通过指针调用对象的成员函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;      <span class="comment">// 创建对象</span></span><br><span class="line">    obj.value = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    MyClass* ptr = &amp;obj;  <span class="comment">// 创建指向对象的指针</span></span><br><span class="line">    ptr-&gt;<span class="built_in">display</span>();       <span class="comment">// 使用箭头操作符调用成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>ptr-&gt;display()</code> 等同于 <code>(*ptr).display()</code>。箭头操作符让代码更易于阅读和理解。</p></li></ol><h3 id="总结">总结</h3><ul><li><code>-&gt;</code> 是一个箭头操作符，用于通过指针访问对象的成员。</li><li>与点操作符 <code>.</code> 类似，但 <code>-&gt;</code> 需要左操作数是一个指针，指向一个对象。</li><li>它简化了指针操作，使代码更加直观和易于理解。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在C++中，&lt;code&gt;-&amp;gt;&lt;/code&gt; 操作符通常被称为&lt;strong&gt;箭头操作符&lt;/strong&gt;（Arrow Operator）或&lt;strong&gt;成员访问运算符通过指针&lt;/strong&gt;（Member Access Operator via Pointer）。</summary>
      
    
    
    
    <category term="Study" scheme="http://jasperfanger.github.io/categories/Study/"/>
    
    <category term="C++" scheme="http://jasperfanger.github.io/categories/Study/C/"/>
    
    
    <category term="C++" scheme="http://jasperfanger.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【C++】 范围解析运算符</title>
    <link href="http://jasperfanger.github.io/posts/fdd2db60.html"/>
    <id>http://jasperfanger.github.io/posts/fdd2db60.html</id>
    <published>2024-09-02T02:54:41.000Z</published>
    <updated>2024-09-12T10:00:00.014Z</updated>
    
    <content type="html"><![CDATA[<p>在 C++ 中，两个冒号 (<code>::</code>) 是<strong>范围解析运算符</strong>（Scope Resolution Operator）。它用于指明一个特定的范围，通常是用于区分不同作用域中的同名符号（如变量、函数、类等）。</p><h3 id="主要用途">主要用途</h3><ol><li><p><strong>访问类的成员</strong>：<br>当定义一个类的成员函数时，范围解析运算符用于指定该函数属于哪个类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>; <span class="comment">// 函数声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用范围解析运算符定义成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;This is a member function of MyClass.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>MyClass::display</code> 指明了 <code>display</code> 是 <code>MyClass</code> 类的成员函数。</p></li><li><p><strong>全局作用域访问</strong>：<br>在 C++ 中，如果局部变量的名字与全局变量相同，范围解析运算符可以用于访问全局变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = <span class="number">10</span>; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">20</span>; <span class="comment">// 局部变量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Local value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;       <span class="comment">// 输出：Local value: 20</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Global value: &quot;</span> &lt;&lt; ::value &lt;&lt; std::endl;    <span class="comment">// 输出：Global value: 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此例中，<code>::value</code> 用于访问全局作用域中的变量 <code>value</code>。</p></li><li><p><strong>访问命名空间中的成员</strong>：<br>C++ 使用命名空间来组织代码并避免命名冲突。范围解析运算符用于访问命名空间中的成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> MyNamespace &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Function inside MyNamespace.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用范围解析运算符访问命名空间成员</span></span><br><span class="line">    MyNamespace::<span class="built_in">myFunction</span>(); <span class="comment">// 输出：Function inside MyNamespace.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>MyNamespace::myFunction</code> 指定 <code>myFunction</code> 是 <code>MyNamespace</code> 命名空间中的函数。</p></li><li><p><strong>访问枚举的成员</strong>：<br>如果枚举的成员名在当前作用域中可能会引起混淆，范围解析运算符也可用于指明它属于哪个枚举类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    RED,</span><br><span class="line">    GREEN,</span><br><span class="line">    BLUE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Color myColor = Color::RED; <span class="comment">// 使用范围解析符访问枚举成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，<code>Color::RED</code> 明确表示 <code>RED</code> 是 <code>Color</code> 枚举的成员。</p></li></ol><h3 id="总结">总结</h3><ul><li><code>::</code> 是范围解析运算符，用于指明所属的类、命名空间或全局作用域。</li><li>它帮助区分不同作用域中的同名符号，并在类成员定义、全局变量访问、命名空间成员访问、枚举成员访问等方面起到重要作用。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 C++ 中，两个冒号 (&lt;code&gt;::&lt;/code&gt;) 是&lt;strong&gt;范围解析运算符&lt;/strong&gt;（Scope Resolution Operator）。它用于指明一个特定的范围，通常是用于区分不同作用域中的同名符号（如变量、函数、类等）。&lt;/p&gt;
&lt;h3 i</summary>
      
    
    
    
    <category term="Study" scheme="http://jasperfanger.github.io/categories/Study/"/>
    
    <category term="C++" scheme="http://jasperfanger.github.io/categories/Study/C/"/>
    
    
    <category term="C++" scheme="http://jasperfanger.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【MATLAB】 四阶龙格库塔求解器（以二阶弹簧阻尼系统为例）</title>
    <link href="http://jasperfanger.github.io/posts/2bea5c23.html"/>
    <id>http://jasperfanger.github.io/posts/2bea5c23.html</id>
    <published>2024-08-29T02:22:41.000Z</published>
    <updated>2024-09-12T10:00:00.013Z</updated>
    
    <content type="html"><![CDATA[<p>有时候不方便用MATLAB中自带的求解器，写一个定步长的四阶龙格库塔求解器。</p><span id="more"></span><hr><p>四阶龙格库塔function</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[t, y]</span> = <span class="title">rungeKutta4</span><span class="params">(odefun, tspan, y0, h)</span></span></span><br><span class="line">    <span class="comment">% 输入参数:</span></span><br><span class="line">    <span class="comment">% odefun - 常微分方程的函数句柄 (dy/dt = f(t, y))</span></span><br><span class="line">    <span class="comment">% tspan  - 时间区间 [t0, tf]</span></span><br><span class="line">    <span class="comment">% y0     - 初始条件</span></span><br><span class="line">    <span class="comment">% h      - 时间步长</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">% 输出参数:</span></span><br><span class="line">    <span class="comment">% t      - 时间点数组</span></span><br><span class="line">    <span class="comment">% y      - 解的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% 初始化</span></span><br><span class="line">    t0 = tspan(<span class="number">1</span>);</span><br><span class="line">    tf = tspan(<span class="number">2</span>);</span><br><span class="line">    t = t0:h:tf;  <span class="comment">% 生成时间点</span></span><br><span class="line">    n = <span class="built_in">length</span>(t);</span><br><span class="line">    y = <span class="built_in">zeros</span>(<span class="built_in">length</span>(y0), n);</span><br><span class="line">    y(:,<span class="number">1</span>) = y0;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">% 四阶龙格库塔算法</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n<span class="number">-1</span></span><br><span class="line">        k1 = h * odefun(t(<span class="built_in">i</span>), y(:,<span class="built_in">i</span>));</span><br><span class="line">        k2 = h * odefun(t(<span class="built_in">i</span>) + <span class="number">0.5</span>*h, y(:,<span class="built_in">i</span>) + <span class="number">0.5</span>*k1);</span><br><span class="line">        k3 = h * odefun(t(<span class="built_in">i</span>) + <span class="number">0.5</span>*h, y(:,<span class="built_in">i</span>) + <span class="number">0.5</span>*k2);</span><br><span class="line">        k4 = h * odefun(t(<span class="built_in">i</span>) + h, y(:,<span class="built_in">i</span>) + k3);</span><br><span class="line">  </span><br><span class="line">        y(:,<span class="built_in">i</span>+<span class="number">1</span>) = y(:,<span class="built_in">i</span>) + (k1 + <span class="number">2</span>*k2 + <span class="number">2</span>*k3 + k4) / <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><hr><p>二阶弹簧阻尼系统</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">dx</span> = <span class="title">damped_system</span><span class="params">(t, x)</span></span></span><br><span class="line">    <span class="comment">% 输入参数：</span></span><br><span class="line">    <span class="comment">%   t - 时间</span></span><br><span class="line">    <span class="comment">%   x - 状态向量，x(1) 为位移 x，x(2) 为速度 v = dx/dt</span></span><br><span class="line">    <span class="comment">%   m - 质量</span></span><br><span class="line">    <span class="comment">%   c - 阻尼系数</span></span><br><span class="line">    <span class="comment">%   k - 弹簧常数</span></span><br><span class="line">    <span class="comment">% 输出：</span></span><br><span class="line">    <span class="comment">%   dx - 状态向量的导数，dx(1) 为速度，dx(2) 为加速度</span></span><br><span class="line">    m=<span class="number">2</span>;</span><br><span class="line">    c=<span class="number">0.9</span>;</span><br><span class="line">    k=<span class="number">0.5</span>;</span><br><span class="line">    <span class="comment">% 初始化导数向量</span></span><br><span class="line">    dx = <span class="built_in">zeros</span>(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">% 一阶导数为速度</span></span><br><span class="line">    dx(<span class="number">1</span>) = x(<span class="number">2</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">% 二阶导数为加速度，根据二阶阻尼系统方程</span></span><br><span class="line">    dx(<span class="number">2</span>) = -(c/m) * x(<span class="number">2</span>) - (k/m) * x(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><hr><p>使用RK4求解二阶弹簧阻尼</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 定义微分方程</span></span><br><span class="line">odefun = @damped_system;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 定义时间区间、初始条件和时间步长</span></span><br><span class="line">tspan = [<span class="number">0</span>, <span class="number">20</span>];  <span class="comment">% 从0到2秒的时间区间</span></span><br><span class="line">y0 = [<span class="number">0.1</span>; <span class="number">0</span>];     <span class="comment">% 初始条件，x1(0) = 1, x2(0) = 1</span></span><br><span class="line">h = <span class="number">0.1</span>;         <span class="comment">% 时间步长</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 使用四阶龙格库塔求解器</span></span><br><span class="line">[t, y] = rungeKutta4(odefun, tspan, y0, h);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制结果</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(t, y(<span class="number">1</span>, :), <span class="string">&#x27;-o&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Time t&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;x1(t)&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;Solution of x1(t) using Runge-Kutta 4th order method&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(t, y(<span class="number">2</span>, :), <span class="string">&#x27;-o&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Time t&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;x2(t)&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;Solution of x2(t) using Runge-Kutta 4th order method&#x27;</span>);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://img.picui.cn/free/2024/08/29/66d04fcc1808e.png" alt="rk4"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有时候不方便用MATLAB中自带的求解器，写一个定步长的四阶龙格库塔求解器。&lt;/p&gt;</summary>
    
    
    
    <category term="Keys" scheme="http://jasperfanger.github.io/categories/Keys/"/>
    
    <category term="Matlab" scheme="http://jasperfanger.github.io/categories/Keys/Matlab/"/>
    
    
    <category term="Matlab" scheme="http://jasperfanger.github.io/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>【MATLAB】 在MATLAB中调用其他脚本</title>
    <link href="http://jasperfanger.github.io/posts/42479ac6.html"/>
    <id>http://jasperfanger.github.io/posts/42479ac6.html</id>
    <published>2024-08-29T02:22:41.000Z</published>
    <updated>2024-09-12T10:00:00.013Z</updated>
    
    <content type="html"><![CDATA[<p>在 MATLAB 中，你可以使用以下步骤调用其他脚本中的函数：</p><p>确定要调用的脚本所在的文件夹，将该文件夹添加到 MATLAB 的搜索路径中。你可以使用 <code>addpath</code>命令来添加路径。</p><p>在 MATLAB 中打开要调用函数的脚本文件。</p><p>在脚本文件中，使用函数名和参数调用所需的函数。例如，如果要调用名为 myFunction 的函数并传递两个参数 x 和 y，则可以编写 <code>myFunction(x, y)</code>。</p><p>运行脚本文件，MATLAB 将自动查找并运行所调用的函数。</p><p>以下是一些示例代码，用于说明如何调用其他脚本中的函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 添加要调用的脚本所在的文件夹到 MATLAB 的搜索路径中</span></span><br><span class="line">addpath(<span class="string">&#x27;C:\Users\Username\Documents\MATLAB\MyFunctions&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 在 MATLAB 中打开要调用函数的脚本文件</span></span><br><span class="line"><span class="comment">% MyScript.m 包含名为 myFunction 的函数</span></span><br><span class="line">open(<span class="string">&#x27;C:\Users\Username\Documents\MATLAB\MyScript.m&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 在脚本文件中调用所需的函数</span></span><br><span class="line"><span class="comment">% myFunction 需要两个输入参数 x 和 y</span></span><br><span class="line">x = <span class="number">1</span>;</span><br><span class="line">y = <span class="number">2</span>;</span><br><span class="line">myFunction(x, y);</span><br></pre></td></tr></table></figure><p>请注意，如果要使用其他脚本中的函数，你需要确保该函数在被调用之前已经定义。</p><h2 id="matlab如何调用matlab脚本中的函数">matlab如何调用matlab脚本中的函数</h2><p>在MATLAB中，可以使用addpath函数将包含您的脚本和函数的文件夹添加到MATLAB搜索路径中。</p><p>然后，您可以使用run函数运行脚本并调用其中的函数。</p><p>例如，假设您有一个名为 <code>myScript.m</code>的脚本，其中包含一个名为 <code>myFunction</code>的函数。</p><p>您可以按照以下步骤调用该函数：</p><p>将包含 <code>myScript.m</code>的文件夹添加到MATLAB搜索路径中：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addpath(<span class="string">&#x27;/path/to/myScript/folder&#x27;</span>)</span><br></pre></td></tr></table></figure><p>运行脚本并调用函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">run(<span class="string">&#x27;myScript.m&#x27;</span>)</span><br><span class="line">output = myFunction(input)</span><br></pre></td></tr></table></figure><p>其中，<code>input</code>是传递给 <code>myFunction</code>的输入参数，<code>output</code>是函数的输出结果。<br>注意，如果您的脚本和函数位于当前工作目录中，则无需使用 <code>addpath</code>函数将其添加到搜索路径中。</p><h2 id="matlab调用py脚本">matlab调用py脚本</h2><p>你可以使用Matlab的py函数来调用Python脚本。下面是一个简单的示例：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 设置Python解释器路径（如果需要）</span></span><br><span class="line"><span class="comment">% pyversion(&#x27;path/to/python&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 调用Python脚本</span></span><br><span class="line">py.my_script</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>my_script</code>是你想要调用的 <code>Python</code>脚本文件（无需扩展名）。</p><p>你还可以传递参数给 <code>Python</code>脚本。例如：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 调用带有参数的Python脚本</span></span><br><span class="line">arg1 = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">arg2 = <span class="string">&#x27;World&#x27;</span>;</span><br><span class="line">py.my_script(arg1, arg2)</span><br></pre></td></tr></table></figure><p>这将把 <code>arg1</code>和 <code>arg2</code>作为参数传递给Python脚本。</p><p>请确保你已经安装了对应的Python版本，并且在Matlab中设置了正确的Python解释器路径（如果需要）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 MATLAB 中，你可以使用以下步骤调用其他脚本中的函数：&lt;/p&gt;
&lt;p&gt;确定要调用的脚本所在的文件夹，将该文件夹添加到 MATLAB 的搜索路径中。你可以使用 &lt;code&gt;addpath&lt;/code&gt;命令来添加路径。&lt;/p&gt;
&lt;p&gt;在 MATLAB 中打开要调用函数的</summary>
      
    
    
    
    <category term="Keys" scheme="http://jasperfanger.github.io/categories/Keys/"/>
    
    <category term="Matlab" scheme="http://jasperfanger.github.io/categories/Keys/Matlab/"/>
    
    
    <category term="Matlab" scheme="http://jasperfanger.github.io/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】 1103 分糖果2</title>
    <link href="http://jasperfanger.github.io/posts/76fa9a46.html"/>
    <id>http://jasperfanger.github.io/posts/76fa9a46.html</id>
    <published>2024-08-26T02:29:18.000Z</published>
    <updated>2024-09-12T10:00:00.010Z</updated>
    
    <content type="html"><![CDATA[<h1>题目：   <a href="https://leetcode.cn/problems/distribute-candies-to-people/description/">1103.分糖果2</a></h1><h2 id="题面">题面</h2><p>排排坐，分糖果。</p><p>我们买了一些糖果 candies，打算把它们分给排好队的 n = num_people 个小朋友。</p><p>给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。</p><p>然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗，依此类推，直到给最后一个小朋友 2 * n 颗糖果。</p><p>重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。</p><p>返回一个长度为 num_people、元素之和为 candies 的数组，以表示糖果的最终分发情况（即 ans[i] 表示第 i 个小朋友分到的糖果数）。</p><h2 id="示例">示例</h2><p>示例 1：<br>输入：candies = 7, num_people = 4<br>输出：[1,2,3,1]<br>解释：<br>第一次，ans[0] += 1，数组变为 [1,0,0,0]。<br>第二次，ans[1] += 2，数组变为 [1,2,0,0]。<br>第三次，ans[2] += 3，数组变为 [1,2,3,0]。<br>第四次，ans[3] += 1（因为此时只剩下 1 颗糖果），最终数组变为 [1,2,3,1]。</p><h2 id="Tips">Tips</h2><p>1 &lt;= candies &lt;= 10^9<br>1 &lt;= num_people &lt;= 1000</p><h2 id="Code">Code</h2><h3 id="代码解释">代码解释</h3><p>这段 C++ 代码的目的是计算一个整数向量 <code>nums</code> 中，将所有非零元素变为 0 所需的最小操作次数。每次操作可以选择一个正整数 <code>x</code>，然后将 <code>nums</code> 中所有大于或等于 <code>x</code> 的元素减去 <code>x</code>。最终，这个问题可以转化为计算 <code>nums</code> 中不同非零整数的数量。</p><h4 id="原始代码">原始代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dic</span><span class="params">(<span class="number">101</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            dic[nums[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">101</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dic[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="逐行解释">逐行解释</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br></pre></td></tr></table></figure><ul><li>这是 C++ 类 <code>Solution</code> 的定义开始，这是编程竞赛和平台（如 LeetCode）上常用的代码结构，用来封装解决方案。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minimumOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br></pre></td></tr></table></figure><ul><li>定义了一个公共成员函数 <code>minimumOperations</code>，它接收一个整数向量 <code>nums</code> 作为引用参数，并返回一个整数结果。函数的目的是计算将 <code>nums</code> 中所有非零元素变为 0 所需的最小操作次数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dic</span><span class="params">(<span class="number">101</span>, <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>定义了一个大小为 101 的布尔类型向量 <code>dic</code>，并初始化为 <code>0</code>。这个向量用于记录 <code>nums</code> 中出现的数字，假设 <code>nums</code> 中的数字范围是 0 到 100。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure><ul><li>获取 <code>nums</code> 向量的大小，并将其存储在 <code>len</code> 变量中。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">    dic[nums[i]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个 <code>for</code> 循环遍历 <code>nums</code> 向量的每一个元素。对于每个 <code>nums[i]</code>，将 <code>dic[nums[i]]</code> 设置为 <code>1</code>，表示该数字在 <code>nums</code> 中出现过。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><ul><li>定义了一个整数变量 <code>res</code>，并将其初始化为 <code>0</code>。这个变量将用于计数 <code>nums</code> 中不同非零整数的数量。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">101</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dic[i] == <span class="number">1</span>)&#123;</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个 <code>for</code> 循环遍历从 1 到 100 的所有整数。对于每一个 <code>i</code>，如果 <code>dic[i]</code> 的值为 <code>1</code>，说明该整数在 <code>nums</code> 中出现过，则将 <code>res</code> 递增 1。这个过程计算了 <code>nums</code> 中不同非零整数的数量。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>最后，函数返回 <code>res</code> 的值，即 <code>nums</code> 向量中不同非零整数的数量。这个数量代表将 <code>nums</code> 中所有非零元素变为 0 所需的最少操作次数。类定义在此结束。</li></ul><h3 id="代码总结">代码总结</h3><p>这段代码的核心逻辑是使用布尔向量 <code>dic</code> 来记录 <code>nums</code> 中出现的每个非零整数，然后通过遍历 <code>dic</code> 来计算不同非零整数的数量。<br>这些不同的非零整数即表示需要进行的最小操作次数。代码的时间复杂度为 O(n)，其中 n 是 <code>nums</code> 向量的长度；<br>空间复杂度为 O(1)，因为 <code>dic</code> 向量的大小是固定的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目：   &lt;a href=&quot;https://leetcode.cn/problems/distribute-candies-to-people/description/&quot;&gt;1103.分糖果2&lt;/a&gt;&lt;/h1&gt;
&lt;h2 id=&quot;题面&quot;&gt;题面&lt;/h2&gt;
&lt;p&gt;排排坐，分糖果</summary>
      
    
    
    
    <category term="Study" scheme="http://jasperfanger.github.io/categories/Study/"/>
    
    <category term="leetcode" scheme="http://jasperfanger.github.io/categories/Study/leetcode/"/>
    
    
    <category term="leetcode" scheme="http://jasperfanger.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】 121 买卖股票的最佳时机</title>
    <link href="http://jasperfanger.github.io/posts/866548f3.html"/>
    <id>http://jasperfanger.github.io/posts/866548f3.html</id>
    <published>2024-08-26T02:29:18.000Z</published>
    <updated>2024-09-12T10:00:00.010Z</updated>
    
    <content type="html"><![CDATA[<h1>题目：   <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">121 买卖股票的最佳时机</a></h1><h2 id="题面">题面</h2><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><h2 id="示例">示例</h2><p>示例 1：</p><p>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br>示例 2：</p><p>输入：prices = [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</p><h2 id="Tips">Tips</h2><p>1 &lt;= prices.length &lt;= 105<br>0 &lt;= prices[i] &lt;= 104</p><h2 id="Code">Code</h2><h3 id="代码解释">代码解释</h3><p>这段 C++ 代码旨在解决一个典型的动态规划问题：给定一个整数向量 <code>prices</code>，其中 <code>prices[i]</code> 表示某只股票在第 <code>i</code> 天的价格，计算可以通过一次买入和一次卖出所能获得的最大利润。你不能在买入股票之前卖出股票。</p><h4 id="原始代码">原始代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> low = INT_MAX;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            low = <span class="built_in">min</span>(low, prices[i]);  <span class="comment">// 取最左最小价格</span></span><br><span class="line">            result = <span class="built_in">max</span>(result, prices[i] - low); <span class="comment">// 直接取最大区间利润</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="逐行解释">逐行解释</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br></pre></td></tr></table></figure><ul><li>这是一个 C++ 类 <code>Solution</code> 的定义开始，这是编程竞赛和平台（如 LeetCode）上常用的代码结构，用来封装解决方案。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br></pre></td></tr></table></figure><ul><li>这里定义了一个公共成员函数 <code>maxProfit</code>，它接收一个整数向量 <code>prices</code> 作为引用参数，并返回一个整数结果。这个函数的目的是计算通过一次买入和一次卖出股票所能获得的最大利润。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> low = INT_MAX;</span><br></pre></td></tr></table></figure><ul><li>定义了一个整数变量 <code>low</code>，并初始化为 <code>INT_MAX</code>，表示当前找到的最低价格。<code>INT_MAX</code> 是一个非常大的数值，确保在循环中第一次比较时 <code>prices[i]</code> 的值会被替代。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> result = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><ul><li>定义了一个整数变量 <code>result</code>，并将其初始化为 <code>0</code>，表示当前找到的最大利润。最初的利润为零，因为如果没有利润的可能，最优解是零。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br></pre></td></tr></table></figure><ul><li>这个 <code>for</code> 循环遍历 <code>prices</code> 向量的每一个元素，索引为 <code>i</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">low = <span class="built_in">min</span>(low, prices[i]);  <span class="comment">// 取最左最小价格</span></span><br></pre></td></tr></table></figure><ul><li>在循环的每一步，更新 <code>low</code>，将其设为当前的最小价格。<code>min(low, prices[i])</code> 会在当前 <code>low</code> 和 <code>prices[i]</code> 中选择较小的一个，保证 <code>low</code> 始终是遍历过的价格中的最小值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="built_in">max</span>(result, prices[i] - low); <span class="comment">// 直接取最大区间利润</span></span><br></pre></td></tr></table></figure><ul><li>计算 <code>prices[i] - low</code>，即当前价格与之前找到的最小价格之间的差值，这是在第 <code>i</code> 天卖出股票所能获得的最大利润。<code>max(result, prices[i] - low)</code> 用来更新 <code>result</code>，选择当前的最大利润。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>循环结束后，函数返回 <code>result</code> 的值，这个值就是一次买入和一次卖出所能获得的最大利润。类的定义到此结束。</li></ul><h3 id="代码总结">代码总结</h3><p>这段代码通过遍历 <code>prices</code> 数组，一次扫描找出最低的买入价格，并在每一步计算可能的最大利润。<br>最终得到的 <code>result</code> 是一次买入和卖出所能获得的最大利润。</p><ul><li><strong>时间复杂度</strong>：O(n)，其中 n 是 <code>prices</code> 向量的长度。</li><li><strong>空间复杂度</strong>：O(1)，因为只使用了常数空间。</li></ul><p>这段代码简洁且高效，利用动态更新的方法，在遍历的同时计算出最大利润。</p><p>b站上有思路解析：<a href="https://www.bilibili.com/video/BV1Xe4y1u77q/?vd_source=91cccc7057f9b07f9eb9c28c63e0b4e4">https://www.bilibili.com/video/BV1Xe4y1u77q/?vd_source=91cccc7057f9b07f9eb9c28c63e0b4e4</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目：   &lt;a href=&quot;https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/&quot;&gt;121 买卖股票的最佳时机&lt;/a&gt;&lt;/h1&gt;
&lt;h2 id=&quot;题面&quot;&gt;题面&lt;/h2&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="Study" scheme="http://jasperfanger.github.io/categories/Study/"/>
    
    <category term="leetcode" scheme="http://jasperfanger.github.io/categories/Study/leetcode/"/>
    
    
    <category term="leetcode" scheme="http://jasperfanger.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】 122 买卖股票的最佳时机2</title>
    <link href="http://jasperfanger.github.io/posts/7a465dfb.html"/>
    <id>http://jasperfanger.github.io/posts/7a465dfb.html</id>
    <published>2024-08-26T02:29:18.000Z</published>
    <updated>2024-09-12T10:00:00.011Z</updated>
    
    <content type="html"><![CDATA[<h1>题目：   <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">122 买卖股票的最佳时机2</a></h1><h2 id="题面">题面</h2><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p><p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</p><p>返回 你能获得的 最大 利润 。</p><h2 id="示例">示例</h2><p>示例 1：</p><p>输入：prices = [7,1,5,3,6,4]<br>输出：7<br>解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。<br>随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3。<br>最大总利润为 4 + 3 = 7 。<br>示例 2：</p><p>输入：prices = [1,2,3,4,5]<br>输出：4<br>解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。<br>最大总利润为 4 。<br>示例 3：</p><p>输入：prices = [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0。</p><h2 id="Tips">Tips</h2><p>1 &lt;= prices.length &lt;= 3 * 104<br>0 &lt;= prices[i] &lt;= 104</p><h2 id="Code">Code</h2><h3 id="代码解释">代码解释</h3><p>这段 C++ 代码解决了股票买卖的另一个经典问题：在允许进行多次买卖的情况下，如何通过多次交易（买入和卖出）来获取最大利润。代码的核心思想是通过每天买卖股票的价格差来积累总利润。</p><h4 id="原始代码">原始代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (tmp &gt; <span class="number">0</span>) profit += tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="逐行解释">逐行解释</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br></pre></td></tr></table></figure><ul><li>这是 <code>Solution</code> 类的定义开始。这是 LeetCode 等编程平台上常用的代码结构，用来封装一个解决方案。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br></pre></td></tr></table></figure><ul><li>定义了一个公共成员函数 <code>maxProfit</code>，它接收一个整数向量 <code>prices</code> 作为引用参数，并返回一个整数值，表示可以通过多次买卖股票获得的最大利润。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> profit = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><ul><li>定义一个整数变量 <code>profit</code>，并将其初始化为 <code>0</code>，表示当前累积的利润。初始利润为零，因为一开始没有进行任何交易。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br></pre></td></tr></table></figure><ul><li>这个 <code>for</code> 循环从第二天（<code>i = 1</code>）开始遍历 <code>prices</code> 向量，逐步考察每一天的股票价格。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tmp = prices[i] - prices[i - <span class="number">1</span>];</span><br></pre></td></tr></table></figure><ul><li>计算 <code>tmp</code>，即当天的股票价格与前一天价格之间的差值。这一步判断在两天之间买卖是否能获得利润。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tmp &gt; <span class="number">0</span>) profit += tmp;</span><br></pre></td></tr></table></figure><ul><li>如果 <code>tmp</code> 大于零，表示价格上涨了，因此将这部分利润加入到 <code>profit</code> 中。即每天只要股票价格上涨，就卖出股票获得利润。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>循环结束后，函数返回 <code>profit</code> 的值，即通过多次买卖股票所能获得的最大利润。类的定义到此结束。</li></ul><h3 id="代码总结">代码总结</h3><p>这段代码的核心思想是贪心算法：只要股票价格上涨，就计算当日买入并卖出的利润，积累每天的收益，最终获得最大利润。</p><ul><li><strong>时间复杂度</strong>：O(n)，其中 n 是 <code>prices</code> 向量的长度。</li><li><strong>空间复杂度</strong>：O(1)，因为只使用了常数空间。</li></ul><p>这段代码简洁且高效，通过简单的遍历和条件判断，就能计算出在允许多次买卖的情况下所能获得的最大利润。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目：   &lt;a href=&quot;https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/&quot;&gt;122 买卖股票的最佳时机2&lt;/a&gt;&lt;/h1&gt;
&lt;h2 id=&quot;题面&quot;&gt;题面&lt;/h2&gt;</summary>
      
    
    
    
    <category term="Study" scheme="http://jasperfanger.github.io/categories/Study/"/>
    
    <category term="leetcode" scheme="http://jasperfanger.github.io/categories/Study/leetcode/"/>
    
    
    <category term="leetcode" scheme="http://jasperfanger.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】 2357 使数组中所有元素都等于零</title>
    <link href="http://jasperfanger.github.io/posts/915a8182.html"/>
    <id>http://jasperfanger.github.io/posts/915a8182.html</id>
    <published>2024-08-26T02:29:18.000Z</published>
    <updated>2024-09-12T10:00:00.011Z</updated>
    
    <content type="html"><![CDATA[<h1>题目：   <a href="https://leetcode.cn/problems/make-array-zero-by-subtracting-equal-amounts/description/">2357 使数组中所有元素都等于零</a></h1><h2 id="题面">题面</h2><p>给你一个非负整数数组 nums 。在一步操作中，你必须：</p><p>选出一个正整数 x ，x 需要小于或等于 nums 中 最小的非零元素。<br>nums 中的每个正整数都减去 x。<br>返回使 nums 中所有元素都等于 0 需要的 最少 操作数。</p><h2 id="示例">示例</h2><p>示例 1：</p><p>输入：nums = [1,5,0,3,5]<br>输出：3<br>解释：<br>第一步操作：选出 x = 1 ，之后 nums = [0,4,0,2,4] 。<br>第二步操作：选出 x = 2 ，之后 nums = [0,2,0,0,2] 。<br>第三步操作：选出 x = 2 ，之后 nums = [0,0,0,0,0] 。<br>示例 2：</p><p>输入：nums = [0]<br>输出：0<br>解释：nums 中的每个元素都已经是 0 ，所以不需要执行任何操作。</p><h2 id="Tips">Tips</h2><p>1 &lt;= nums.length &lt;= 100<br>0 &lt;= nums[i] &lt;= 100</p><h2 id="Code">Code</h2><h3 id="代码解释">代码解释</h3><p>这段 C++ 代码的目的是计算一个整数向量 <code>nums</code> 中，将所有非零元素变为 0 所需的最小操作次数。每次操作可以选择一个正整数 <code>x</code>，然后将 <code>nums</code> 中所有大于或等于 <code>x</code> 的元素减去 <code>x</code>。最终，这个问题可以转化为计算 <code>nums</code> 中不同非零整数的数量。</p><h4 id="原始代码">原始代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dic</span><span class="params">(<span class="number">101</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            dic[nums[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">101</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dic[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="逐行解释">逐行解释</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br></pre></td></tr></table></figure><ul><li>这是 C++ 类 <code>Solution</code> 的定义开始，这是编程竞赛和平台（如 LeetCode）上常用的代码结构，用来封装解决方案。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minimumOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br></pre></td></tr></table></figure><ul><li>定义了一个公共成员函数 <code>minimumOperations</code>，它接收一个整数向量 <code>nums</code> 作为引用参数，并返回一个整数结果。函数的目的是计算将 <code>nums</code> 中所有非零元素变为 0 所需的最小操作次数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dic</span><span class="params">(<span class="number">101</span>, <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>定义了一个大小为 101 的布尔类型向量 <code>dic</code>，并初始化为 <code>0</code>。这个向量用于记录 <code>nums</code> 中出现的数字，假设 <code>nums</code> 中的数字范围是 0 到 100。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure><ul><li>获取 <code>nums</code> 向量的大小，并将其存储在 <code>len</code> 变量中。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">    dic[nums[i]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个 <code>for</code> 循环遍历 <code>nums</code> 向量的每一个元素。对于每个 <code>nums[i]</code>，将 <code>dic[nums[i]]</code> 设置为 <code>1</code>，表示该数字在 <code>nums</code> 中出现过。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><ul><li>定义了一个整数变量 <code>res</code>，并将其初始化为 <code>0</code>。这个变量将用于计数 <code>nums</code> 中不同非零整数的数量。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">101</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dic[i] == <span class="number">1</span>)&#123;</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个 <code>for</code> 循环遍历从 1 到 100 的所有整数。对于每一个 <code>i</code>，如果 <code>dic[i]</code> 的值为 <code>1</code>，说明该整数在 <code>nums</code> 中出现过，则将 <code>res</code> 递增 1。这个过程计算了 <code>nums</code> 中不同非零整数的数量。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>最后，函数返回 <code>res</code> 的值，即 <code>nums</code> 向量中不同非零整数的数量。这个数量代表将 <code>nums</code> 中所有非零元素变为 0 所需的最少操作次数。类定义在此结束。</li></ul><h3 id="代码总结">代码总结</h3><p>这段代码的核心逻辑是使用布尔向量 <code>dic</code> 来记录 <code>nums</code> 中出现的每个非零整数，然后通过遍历 <code>dic</code> 来计算不同非零整数的数量。<br>这些不同的非零整数即表示需要进行的最小操作次数。代码的时间复杂度为 O(n)，其中 n 是 <code>nums</code> 向量的长度；<br>空间复杂度为 O(1)，因为 <code>dic</code> 向量的大小是固定的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目：   &lt;a href=&quot;https://leetcode.cn/problems/make-array-zero-by-subtracting-equal-amounts/description/&quot;&gt;2357 使数组中所有元素都等于零&lt;/a&gt;&lt;/h1&gt;
&lt;h2 id</summary>
      
    
    
    
    <category term="Study" scheme="http://jasperfanger.github.io/categories/Study/"/>
    
    <category term="leetcode" scheme="http://jasperfanger.github.io/categories/Study/leetcode/"/>
    
    
    <category term="leetcode" scheme="http://jasperfanger.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】 2571 礼盒的最大甜蜜度</title>
    <link href="http://jasperfanger.github.io/posts/25e02d38.html"/>
    <id>http://jasperfanger.github.io/posts/25e02d38.html</id>
    <published>2024-08-26T02:29:18.000Z</published>
    <updated>2024-09-12T10:00:00.012Z</updated>
    
    <content type="html"><![CDATA[<h1>题目：   <a href="https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/description/">2571 礼盒的最大甜蜜度</a></h1><h2 id="题面">题面</h2><p>给你一个正整数数组 price ，其中 price[i] 表示第 i 类糖果的价格，另给你一个正整数 k 。</p><p>商店组合 k 类 不同 糖果打包成礼盒出售。礼盒的 甜蜜度 是礼盒中任意两种糖果 价格 绝对差的最小值。</p><p>返回礼盒的 最大 甜蜜度。</p><h2 id="示例">示例</h2><p>示例 1：</p><p>输入：price = [13,5,1,8,21,2], k = 3<br>输出：8<br>解释：选出价格分别为 [13,5,21] 的三类糖果。<br>礼盒的甜蜜度为 min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8, 16) = 8 。<br>可以证明能够取得的最大甜蜜度就是 8 。<br>示例 2：</p><p>输入：price = [1,3,1], k = 2<br>输出：2<br>解释：选出价格分别为 [1,3] 的两类糖果。<br>礼盒的甜蜜度为 min(|1 - 3|) = min(2) = 2 。<br>可以证明能够取得的最大甜蜜度就是 2 。<br>示例 3：</p><p>输入：price = [7,7,7,7], k = 2<br>输出：0<br>解释：从现有的糖果中任选两类糖果，甜蜜度都会是 0 。</p><h2 id="Tips">Tips</h2><p>2 &lt;= k &lt;= price.length &lt;= 105<br>1 &lt;= price[i] &lt;= 109</p><h2 id="Code">Code</h2><h3 id="代码解释">代码解释</h3><p>这段 C++ 代码旨在解决一个优化问题：在给定的价格数组 <code>price</code> 中选择 <code>k</code> 个不同的价格，使得这些价格之间的最小差值最大化。为了解决这个问题，代码采用了二分查找算法。通过二分查找确定可以达到的最大最小差值，并通过遍历数组检查是否可以选择 <code>k</code> 个价格，使得它们之间的差值至少为这个值。</p><h4 id="原始代码">原始代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>()&#123;</span><br><span class="line">        ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">        cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">        cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumTastiness</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; price, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(price.<span class="built_in">begin</span>(), price.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = price.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = price[n - <span class="number">1</span>] - price[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> pre = price[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(price[i]&gt;= pre + mid)&#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    pre = price[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt;= k) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="逐行解释">逐行解释</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br></pre></td></tr></table></figure><ul><li>这是 <code>Solution</code> 类的定义开始。这个类封装了解决问题的方法。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Solution</span>()&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这是 <code>Solution</code> 类的构造函数，用来优化输入和输出的效率。这一部分代码通过禁用 C++ 标准输入输出与 C 标准输入输出的同步，加快了程序的执行速度，特别是在涉及大量 I/O 操作时。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximumTastiness</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; price, <span class="type">int</span> k)</span> </span>&#123;</span><br></pre></td></tr></table></figure><ul><li>这是 <code>maximumTastiness</code> 函数的定义。它接受一个整数向量 <code>price</code> 作为参数，表示一组价格，并且接受一个整数 <code>k</code>，表示需要选择的价格数量。函数返回一个整数值，即最大化的最小差值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(price.<span class="built_in">begin</span>(), price.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><ul><li>这一行对 <code>price</code> 向量进行排序。通过排序，能够方便地找到具有最大最小差值的价格组合。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = price.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure><ul><li>获取 <code>price</code> 向量的大小，并将其存储在变量 <code>n</code> 中。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> l = <span class="number">1</span>, r = price[n - <span class="number">1</span>] - price[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><ul><li>定义 <code>l</code> 和 <code>r</code> 作为二分查找的左右边界。<code>l</code> 初始化为 1，<code>r</code> 初始化为 <code>price</code> 向量中的最大值与最小值的差值。这是可能的最大最小差值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">    <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure><ul><li>进入二分查找循环。<code>mid</code> 表示当前猜测的最小差值，它是左右边界的中点。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> pre = price[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><ul><li>初始化 <code>cnt</code> 为 1，用来统计选择的价格数量。<code>pre</code> 变量保存当前选择的价格，初始值为 <code>price[0]</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(price[i]&gt;= pre + mid)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        pre = price[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这一段代码遍历 <code>price</code> 数组，从第二个元素开始。对于每个价格，如果它与上一个选择的价格之间的差值大于或等于 <code>mid</code>，则选择这个价格，并更新 <code>cnt</code> 和 <code>pre</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(cnt &gt;= k) l = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>如果可以选择的价格数量 <code>cnt</code> 大于或等于 <code>k</code>，说明当前的 <code>mid</code> 是可行的，于是将左边界 <code>l</code> 移动到 <code>mid + 1</code>，尝试寻找更大的差值。否则，将右边界 <code>r</code> 移动到 <code>mid - 1</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>最终返回 <code>r</code>，它代表在 <code>k</code> 个选择的价格中，能够实现的最大最小差值。</li></ul><h3 id="代码总结">代码总结</h3><p>这段代码通过二分查找优化了寻找价格数组中最大化的最小差值的问题。在已经排序的价格数组上，通过二分法确定可以实现的最大最小差值，然后验证能否选择 <code>k</code> 个价格，使它们之间的差值至少为这个值。通过这种方法，代码高效地解决了问题。</p><ul><li><strong>时间复杂度</strong>：O(n log d)，其中 n 是价格数组的长度，d 是价格数组中最大值与最小值的差值。</li><li><strong>空间复杂度</strong>：O(1)，因为只使用了常数空间。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目：   &lt;a href=&quot;https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/description/&quot;&gt;2571 礼盒的最大甜蜜度&lt;/a&gt;&lt;/h1&gt;
&lt;h2 id=&quot;题面&quot;&gt;题面&lt;/h2&gt;
&lt;</summary>
      
    
    
    
    <category term="Study" scheme="http://jasperfanger.github.io/categories/Study/"/>
    
    <category term="leetcode" scheme="http://jasperfanger.github.io/categories/Study/leetcode/"/>
    
    
    <category term="leetcode" scheme="http://jasperfanger.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【solution】恢复右键菜单</title>
    <link href="http://jasperfanger.github.io/posts/73db3ceb.html"/>
    <id>http://jasperfanger.github.io/posts/73db3ceb.html</id>
    <published>2024-08-22T02:22:41.000Z</published>
    <updated>2024-09-12T10:00:00.009Z</updated>
    
    <content type="html"><![CDATA[<p>cmd执行</p><p>Win11切换经典右键菜单：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> <span class="built_in">add</span> <span class="string">&quot;HKCU\Software\Classes\CLSID\&#123;86ca1aa0-34aa-4e8b-a509-50c905bae2a2&#125;\InprocServer32&quot;</span> /<span class="keyword">f</span> /<span class="keyword">ve</span></span><br><span class="line">taskkill /<span class="keyword">f</span> /<span class="keyword">im</span> explorer.<span class="keyword">exe</span> &amp; start explorer.<span class="keyword">exe</span></span><br></pre></td></tr></table></figure><p>Win11恢复回新右键菜单：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> <span class="keyword">delete</span> <span class="string">&quot;HKCU\Software\Classes\CLSID\&#123;86ca1aa0-34aa-4e8b-a509-50c905bae2a2&#125;&quot;</span> /<span class="keyword">f</span></span><br><span class="line">taskkill /<span class="keyword">f</span> /<span class="keyword">im</span> explorer.<span class="keyword">exe</span> &amp; start explorer.<span class="keyword">exe</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;cmd执行&lt;/p&gt;
&lt;p&gt;Win11切换经典右键菜单：&lt;/p&gt;
&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cla</summary>
      
    
    
    
    <category term="Keys" scheme="http://jasperfanger.github.io/categories/Keys/"/>
    
    <category term="Win11" scheme="http://jasperfanger.github.io/categories/Keys/Win11/"/>
    
    
    <category term="Win11 cmd" scheme="http://jasperfanger.github.io/tags/Win11-cmd/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】 1221.分割平衡字符串</title>
    <link href="http://jasperfanger.github.io/posts/1a5246f9.html"/>
    <id>http://jasperfanger.github.io/posts/1a5246f9.html</id>
    <published>2024-08-19T02:13:36.000Z</published>
    <updated>2024-09-12T10:00:00.008Z</updated>
    
    <content type="html"><![CDATA[<h1>题目：   <a href="https://leetcode.cn/problems/split-a-string-in-balanced-strings/">1221.分割平衡字符串</a></h1><h2 id="题面">题面</h2><p>平衡字符串 中，‘L’ 和 ‘R’ 字符的数量是相同的。</p><p>给你一个平衡字符串 s，请你将它分割成尽可能多的子字符串，并满足：</p><p>每个子字符串都是平衡字符串。<br>返回可以通过分割得到的平衡字符串的 最大数量 。</p><h2 id="示例">示例</h2><p>示例 1：</p><p>输入：s = “RLRRLLRLRL”<br>输出：4<br>解释：s 可以分割为 “RL”、“RRLL”、“RL”、“RL” ，每个子字符串中都包含相同数量的 ‘L’ 和 ‘R’ 。<br>示例 2：</p><p>输入：s = “RLRRRLLRLL”<br>输出：2<br>解释：s 可以分割为 “RL”、“RRRLLRLL”，每个子字符串中都包含相同数量的 ‘L’ 和 ‘R’ 。<br>注意，s 无法分割为 “RL”、“RR”、“RL”、“LR”、“LL” 因为第 2 个和第 5 个子字符串不是平衡字符串。<br>示例 3：</p><p>输入：s = “LLLLRRRR”<br>输出：1<br>解释：s 只能保持原样 “LLLLRRRR” 。</p><h2 id="Tips">Tips</h2><p>2 &lt;= s.length &lt;= 1000<br>s[i] = ‘L’ 或 ‘R’<br>s 是一个 平衡 字符串</p><h2 id="Code">Code</h2><h3 id="代码展示">代码展示</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">balancedStringSplit</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, ans = <span class="number">0</span>;  <span class="comment">// 初始化两个整数变量 cnt 和 ans。cnt 用来追踪当前平衡状态，ans 用来记录平衡子字符串的数量。</span></span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c: s) &#123;  <span class="comment">// 使用范围循环（range-based loop），遍历字符串 s 中的每一个字符 c。</span></span><br><span class="line">            cnt += c == <span class="string">&#x27;L&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;  <span class="comment">// 如果当前字符 c 是 &#x27;L&#x27;，则 cnt 增加 1；否则（即 c 是 &#x27;R&#x27;），cnt 减少 1。</span></span><br><span class="line">      </span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">0</span>) ans++;  <span class="comment">// 当 cnt 变为 0 时，表示从上一个平衡点到当前字符之间的部分是一个平衡子字符串，因此 ans 增加 1。</span></span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> ans;  <span class="comment">// 返回 ans 的值，即找到的最大平衡子字符串的数量。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="逐行解释">逐行解释</h3><ol><li><p><strong><code>class Solution &#123; ... &#125;;</code></strong>:</p><ul><li>定义一个名为 <code>Solution</code> 的类。在 LeetCode 上的代码通常需要将函数封装在一个类中，这个类的名字通常为 <code>Solution</code>。</li></ul></li><li><p><strong><code>int balancedStringSplit(string s)</code></strong>:</p><ul><li>在 <code>Solution</code> 类中定义了一个返回整数的函数 <code>balancedStringSplit</code>，该函数接受一个字符串 <code>s</code> 作为输入。这个函数的目的是计算并返回字符串 <code>s</code> 中可以分割成的最大平衡子字符串数量。</li></ul></li><li><p><strong><code>int cnt = 0, ans = 0;</code></strong>:</p><ul><li>定义并初始化两个整数变量 <code>cnt</code> 和 <code>ans</code> 为 0。</li><li><code>cnt</code> 用于跟踪当前的平衡状态：遇到 ‘L’ 字符时，<code>cnt</code> 增加 1；遇到 ‘R’ 字符时，<code>cnt</code> 减少 1。当 <code>cnt</code> 为 0 时，表示当前子字符串是平衡的。</li><li><code>ans</code> 用于记录找到的平衡子字符串的数量。</li></ul></li><li><p><strong><code>for (char c: s) &#123; ... &#125;</code></strong>:</p><ul><li>使用范围循环遍历字符串 <code>s</code> 中的每个字符 <code>c</code>。</li></ul></li><li><p><strong><code>cnt += c == 'L' ? 1 : -1;</code></strong>:</p><ul><li>这是一行紧凑的代码，使用了三元运算符 <code>? :</code>。</li><li>具体来说，这行代码的意思是：如果字符 <code>c</code> 是 ‘L’，那么 <code>cnt</code> 增加 1；否则（字符 <code>c</code> 是 ‘R’），<code>cnt</code> 减少 1。</li></ul></li><li><p><strong><code>if (cnt == 0) ans++;</code></strong>:</p><ul><li>检查当前 <code>cnt</code> 是否为 0。如果 <code>cnt</code> 为 0，表示从上一个平衡点到当前字符构成了一个平衡子字符串，所以将 <code>ans</code> 增加 1。</li></ul></li><li><p><strong><code>return ans;</code></strong>:</p><ul><li>最后，返回 <code>ans</code> 的值，即可以得到的最大平衡子字符串的数量。</li></ul></li></ol><h3 id="逻辑总结">逻辑总结</h3><ul><li>通过遍历字符串 <code>s</code>，我们跟踪当前的平衡状态。</li><li>每当计数器 <code>cnt</code> 为 0 时，表示找到了一个完整的平衡子字符串，因此我们增加计数器 <code>ans</code>。</li><li>最终，<code>ans</code> 的值就是可以通过分割字符串 <code>s</code> 得到的最大平衡子字符串的数量。</li></ul><p>这个算法的时间复杂度为 O(n)，其中 n 是字符串的长度，因此对于大规模输入也能高效处理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目：   &lt;a href=&quot;https://leetcode.cn/problems/split-a-string-in-balanced-strings/&quot;&gt;1221.分割平衡字符串&lt;/a&gt;&lt;/h1&gt;
&lt;h2 id=&quot;题面&quot;&gt;题面&lt;/h2&gt;
&lt;p&gt;平衡字符串 中，‘L</summary>
      
    
    
    
    <category term="Study" scheme="http://jasperfanger.github.io/categories/Study/"/>
    
    <category term="leetcode" scheme="http://jasperfanger.github.io/categories/Study/leetcode/"/>
    
    
    <category term="leetcode" scheme="http://jasperfanger.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】 39.组合总和</title>
    <link href="http://jasperfanger.github.io/posts/3211f2b8.html"/>
    <id>http://jasperfanger.github.io/posts/3211f2b8.html</id>
    <published>2024-08-19T02:13:36.000Z</published>
    <updated>2024-09-12T10:00:00.009Z</updated>
    
    <content type="html"><![CDATA[<h1>题目：   <a href="https://leetcode.cn/problems/combination-sum/description/">39.组合总和</a></h1><h2 id="题面">题面</h2><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><h2 id="示例">示例</h2><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>candidates = <code>[2,3,6,7], </code>target = <code>7</code><strong>输出：</strong>[[2,2,3],[7]]<strong>解释：</strong>2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。7 也是一个候选， 7 = 7 。仅有这两种组合。</pre><p><strong>示例 2：</strong></p><pre><strong>输入: </strong>candidates = [2,3,5]<code>, </code>target = 8<strong>输出: </strong>[[2,2,2,2],[2,3,3],[3,5]]</pre><p><strong>示例 3：</strong></p><pre><strong>输入: </strong>candidates = <code>[2], </code>target = 1<strong>输出: </strong>[]</pre><h2 id="Tips">Tips</h2><ul><li><code>1 &lt;= candidates.length &lt;= 30</code></li><li><code>2 &lt;= candidates[i] &lt;= 40</code></li><li><code>candidates</code> 的所有元素 <strong>互不相同</strong></li><li><code>1 &lt;= target &lt;= 40</code></li></ul><h2 id="Code">Code</h2><h3 id="代码解释">代码解释</h3><p>这段 C++ 代码实现了一个回溯算法，用于求解组合总和问题。给定一个数组 <code>candidates</code> 和一个目标值 <code>target</code>，需要找到所有组合，使得每个组合中的元素之和等于 <code>target</code>。每个元素在组合中可以被重复使用多次。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans; <span class="comment">// 用于存储所有满足条件的组合结果</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 用于存储当前的组合路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯函数，用于生成组合</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当 target 为 0 时，表示找到一个有效组合，将当前路径存入结果中</span></span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历候选数组，从 index 开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; candidates.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前数字大于 target，则跳出循环（剪枝）</span></span><br><span class="line">            <span class="keyword">if</span> (target - candidates[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 选择当前数字，并加入路径</span></span><br><span class="line">                path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">                <span class="comment">// 递归调用，继续寻找组合，注意传递当前索引 i 允许重复使用当前元素</span></span><br><span class="line">                <span class="built_in">backtrack</span>(candidates, target - candidates[i], i);</span><br><span class="line">                <span class="comment">// 回溯，移除最后加入的元素</span></span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主函数，初始化并调用回溯函数</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// 排序候选数组，方便后续剪枝操作</span></span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 调用回溯函数开始搜索</span></span><br><span class="line">        <span class="built_in">backtrack</span>(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 返回最终结果</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="逐行解释">逐行解释</h3><ol><li><p><strong><code>vector&lt;vector&lt;int&gt;&gt; ans;</code></strong>:</p><ul><li>用于存储所有满足条件的组合结果。</li></ul></li><li><p><strong><code>vector&lt;int&gt; path;</code></strong>:</p><ul><li>用于存储当前的组合路径。</li></ul></li><li><p><strong><code>void backtrack(vector&lt;int&gt;&amp; candidates, int target, int index)</code></strong>:</p><ul><li>定义了一个回溯函数，参数包括候选数组 <code>candidates</code>、目标和 <code>target</code> 以及当前递归的起始位置 <code>index</code>。</li></ul></li><li><p><strong><code>if (target == 0) &#123; ans.push_back(path); return; &#125;</code></strong>:</p><ul><li>终止条件之一：如果 <code>target</code> 恰好为 0，表示找到一个符合条件的组合，将当前路径 <code>path</code> 添加到结果集中。</li></ul></li><li><p><strong><code>for (int i = index; i &lt; candidates.size(); i++) &#123; ... &#125;</code></strong>:</p><ul><li>遍历候选数组，从位置 <code>index</code> 开始，尝试所有可能的组合。</li></ul></li><li><p><strong><code>if (target - candidates[i] &lt; 0) &#123; return; &#125;</code></strong>:</p><ul><li>如果当前数字大于 <code>target</code>，则直接返回（剪枝操作），因为数组已排序，后续的数字只会更大。</li></ul></li><li><p><strong><code>path.push_back(candidates[i]);</code></strong>:</p><ul><li>选择当前数字，将其加入路径。</li></ul></li><li><p><strong><code>backtrack(candidates, target - candidates[i], i);</code></strong>:</p><ul><li>递归调用回溯函数，继续尝试减去当前数字后的新目标值。传递 <code>i</code> 允许重复使用当前元素。</li></ul></li><li><p><strong><code>path.pop_back();</code></strong>:</p><ul><li>回溯操作，移除最后一个加入的数字，尝试其他可能的组合。</li></ul></li><li><p><strong><code>vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target)</code></strong>:</p><ul><li>主函数，首先对候选数组进行排序，然后调用回溯函数开始搜索，最后返回结果。</li></ul></li></ol><h3 id="逻辑总结">逻辑总结</h3><ul><li>代码使用回溯算法来枚举所有可能的组合，并通过递归尝试不同的路径。</li><li>每当找到一个符合条件的组合时，结果会被保存下来。</li><li>通过排序和剪枝操作，算法可以有效地减少无效计算，提高运行效率。</li></ul><p>该算法的时间复杂度在最坏情况下为 <code>O(2^n)</code>，其中 <code>n</code> 是数组的长度。虽然通过剪枝操作可以减少部分无效搜索，但对于较大的输入，时间复杂度仍然较高。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目：   &lt;a href=&quot;https://leetcode.cn/problems/combination-sum/description/&quot;&gt;39.组合总和&lt;/a&gt;&lt;/h1&gt;
&lt;h2 id=&quot;题面&quot;&gt;题面&lt;/h2&gt;
&lt;p&gt;给你一个 &lt;strong&gt;无重复元素&lt;/st</summary>
      
    
    
    
    <category term="Study" scheme="http://jasperfanger.github.io/categories/Study/"/>
    
    <category term="leetcode" scheme="http://jasperfanger.github.io/categories/Study/leetcode/"/>
    
    
    <category term="leetcode" scheme="http://jasperfanger.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】 812.最大三角形面积</title>
    <link href="http://jasperfanger.github.io/posts/16ad539c.html"/>
    <id>http://jasperfanger.github.io/posts/16ad539c.html</id>
    <published>2024-08-19T02:13:36.000Z</published>
    <updated>2024-09-12T10:00:00.010Z</updated>
    
    <content type="html"><![CDATA[<h1>题目：   <a href="https://leetcode.cn/problems/largest-triangle-area/">812.最大三角形面积</a></h1><h2 id="题面">题面</h2><p>给你一个由 <strong>X-Y</strong> 平面上的点组成的数组 <code>points</code> ，其中 <code>points[i] = [x&lt;sub&gt;i&lt;/sub&gt;, y&lt;sub&gt;i&lt;/sub&gt;]</code> 。从其中取任意三个不同的点组成三角形，返回能组成的最大三角形的面积。与真实值误差在 <code>10&lt;sup&gt;-5&lt;/sup&gt;</code> 内的答案将会视为正确答案。</p><h2 id="示例">示例</h2><p><strong>示例 1：</strong></p><p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/04/1027.png" alt=""></p><pre><strong>输入：</strong>points = [[0,0],[0,1],[1,0],[0,2],[2,0]]<strong>输出：</strong>2.00000<strong>解释：</strong>输入中的 5 个点如上图所示，红色的三角形面积最大。</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>points = [[1,0],[0,0],[0,1]]<strong>输出：</strong>0.50000</pre><h2 id="Tips">Tips</h2><ul><li><code>3 &lt;= points.length &lt;= 50</code></li><li><code>-50 &lt;= x&lt;sub&gt;i&lt;/sub&gt;, y&lt;sub&gt;i&lt;/sub&gt; &lt;= 50</code></li><li>给出的所有点 <strong>互不相同</strong></li></ul><h2 id="Code">Code</h2><h3 id="代码解释">代码解释</h3><p>这段 C++ 代码的目的是在给定的一组二维平面上的点中，找到面积最大的三角形，并返回该面积。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">largestTriangleArea</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = points.<span class="built_in">size</span>();  <span class="comment">// 获取点的数量</span></span><br><span class="line">        <span class="type">double</span> res = <span class="number">0</span>;  <span class="comment">// 初始化最大面积为0</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 三重循环遍历所有不同的点组合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; j; ++k) &#123;</span><br><span class="line">                    <span class="comment">// 获取三个点的坐标</span></span><br><span class="line">                    <span class="type">int</span> x1 = points[i][<span class="number">0</span>], y1 = points[i][<span class="number">1</span>];</span><br><span class="line">                    <span class="type">int</span> x2 = points[j][<span class="number">0</span>], y2 = points[j][<span class="number">1</span>];</span><br><span class="line">                    <span class="type">int</span> x3 = points[k][<span class="number">0</span>], y3 = points[k][<span class="number">1</span>];</span><br><span class="line">                </span><br><span class="line">                    <span class="comment">// 计算三条边的长度</span></span><br><span class="line">                    <span class="type">double</span> a = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(x1 - x2, <span class="number">2</span>) + <span class="built_in">pow</span>(y1 - y2, <span class="number">2</span>));</span><br><span class="line">                    <span class="type">double</span> b = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(x2 - x3, <span class="number">2</span>) + <span class="built_in">pow</span>(y2 - y3, <span class="number">2</span>));</span><br><span class="line">                    <span class="type">double</span> c = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(x1 - x3, <span class="number">2</span>) + <span class="built_in">pow</span>(y1 - y3, <span class="number">2</span>));</span><br><span class="line">                </span><br><span class="line">                    <span class="comment">// 使用海伦公式计算三角形面积</span></span><br><span class="line">                    <span class="type">double</span> p = (a + b + c) / <span class="number">2</span>;  <span class="comment">// 计算半周长</span></span><br><span class="line">                    <span class="type">double</span> s = <span class="built_in">sqrt</span>(p * (p - a) * (p - b) * (p - c));  <span class="comment">// 计算面积</span></span><br><span class="line">                </span><br><span class="line">                    <span class="comment">// 更新最大面积</span></span><br><span class="line">                    res = <span class="built_in">max</span>(res, s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> res;  <span class="comment">// 返回最大面积</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="逐行解释">逐行解释</h3><ol><li><p><strong><code>int n = points.size();</code></strong>:</p><ul><li>获取输入的点的数量，并存储在变量 <code>n</code> 中。</li></ul></li><li><p><strong><code>double res = 0;</code></strong>:</p><ul><li>初始化变量 <code>res</code>，用于存储最大三角形面积。初始值为0。</li></ul></li><li><p><strong><code>for(int i = 0; i &lt; n; ++i) &#123; ... &#125;</code></strong>:</p><ul><li>使用三重嵌套循环，枚举所有可能的点组合。这三个循环确保从 <code>points</code> 中选择三个不同的点，构成一个三角形。</li></ul></li><li><p><strong><code>int x1 = points[i][0], y1 = points[i][1];</code></strong>:</p><ul><li>这三行分别从 <code>points</code> 数组中提取当前选中的三个点的坐标 <code>(x1, y1)</code>、<code>(x2, y2)</code> 和 <code>(x3, y3)</code>。</li></ul></li><li><p><strong><code>double a = sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2));</code></strong>:</p><ul><li>计算两点之间的距离，使用的是欧几里得距离公式。<code>a</code>、<code>b</code>、<code>c</code> 分别表示三角形的三条边。</li></ul></li><li><p><strong><code>double p = (a + b + c) / 2;</code></strong>:</p><ul><li>计算三角形的半周长 <code>p</code>，即三条边之和除以2。</li></ul></li><li><p><strong><code>double s = sqrt(p * (p - a) * (p - b) * (p - c));</code></strong>:</p><ul><li>使用海伦公式计算三角形的面积 <code>s</code>。海伦公式根据三条边的长度计算三角形面积。</li></ul></li><li><p><strong><code>res = max(res, s);</code></strong>:</p><ul><li>通过比较当前计算的三角形面积 <code>s</code> 与之前的最大面积 <code>res</code>，更新 <code>res</code>，保留最大的三角形面积。</li></ul></li><li><p><strong><code>return res;</code></strong>:</p><ul><li>返回最大三角形的面积。</li></ul></li></ol><h3 id="逻辑总结">逻辑总结</h3><ul><li>该代码的核心思想是通过枚举所有可能的三角形组合，使用海伦公式计算每个三角形的面积，并最终找到并返回最大的三角形面积。</li><li>时间复杂度为 O(n^3)，因为它通过三重循环遍历所有可能的点组合。在点数较少时，这是可行的，但如果点数很多，算法的效率会受到限制。</li></ul><p>假设 <code>points</code> 数组中有 4 个点 <code>[ [0,0], [0,1], [1,0], [1,1] ]</code>：</p><ol><li>枚举出所有三角形组合。</li><li>计算每个三角形的面积。</li><li>找到面积最大的那个三角形，并返回其面积。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目：   &lt;a href=&quot;https://leetcode.cn/problems/largest-triangle-area/&quot;&gt;812.最大三角形面积&lt;/a&gt;&lt;/h1&gt;
&lt;h2 id=&quot;题面&quot;&gt;题面&lt;/h2&gt;
&lt;p&gt;给你一个由 &lt;strong&gt;X-Y&lt;/stron</summary>
      
    
    
    
    <category term="Study" scheme="http://jasperfanger.github.io/categories/Study/"/>
    
    <category term="leetcode" scheme="http://jasperfanger.github.io/categories/Study/leetcode/"/>
    
    
    <category term="leetcode" scheme="http://jasperfanger.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】 877.石子游戏</title>
    <link href="http://jasperfanger.github.io/posts/9cfbfc14.html"/>
    <id>http://jasperfanger.github.io/posts/9cfbfc14.html</id>
    <published>2024-08-19T02:13:36.000Z</published>
    <updated>2024-09-12T10:00:00.009Z</updated>
    
    <content type="html"><![CDATA[<h1>题目：   <a href="https://leetcode.cn/problems/stone-game/description/">877.石子游戏</a></h1><h2 id="题面">题面</h2><p>Alice 和 Bob 用几堆石子在做游戏。一共有偶数堆石子， <strong>排成一行</strong> ；每堆都有 <strong>正</strong> 整数颗石子，数目为 <code>piles[i]</code> 。</p><p>游戏以谁手中的石子最多来决出胜负。石子的 <strong>总数</strong> 是 <strong>奇数</strong> ，所以没有平局。</p><p>Alice 和 Bob 轮流进行，<strong>Alice 先开始</strong> 。 每回合，玩家从行的 <strong>开始</strong> 或 <strong>结束</strong> 处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中 <strong>石子最多</strong> 的玩家 <strong>获胜</strong> 。</p><p>假设 Alice 和 Bob 都发挥出最佳水平，当 Alice 赢得比赛时返回 <code>true</code> ，当 Bob 赢得比赛时返回 <code>false</code> 。</p><h2 id="示例">示例</h2><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>piles = [5,3,4,5]<strong>输出：</strong>true<strong>解释：</strong>Alice 先开始，只能拿前 5 颗或后 5 颗石子 。假设他取了前 5 颗，这一行就变成了 [3,4,5] 。如果 Bob 拿走前 3 颗，那么剩下的是 [4,5]，Alice 拿走后 5 颗赢得 10 分。如果 Bob 拿走后 5 颗，那么剩下的是 [3,4]，Alice 拿走后 4 颗赢得 9 分。这表明，取前 5 颗石子对 Alice 来说是一个胜利的举动，所以返回 true 。</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>piles = [3,7,2,3]<strong>输出：</strong>true</pre><h2 id="Tips">Tips</h2><ul><li><code>2 &lt;= piles.length &lt;= 500</code></li><li><code>piles.length</code> 是 <strong>偶数</strong></li><li><code>1 &lt;= piles[i] &lt;= 500</code></li><li><code>sum(piles[i])</code> 是 <strong>奇数</strong></li></ul><h2 id="Code">Code</h2><h3 id="代码解释">代码解释</h3><p>这段 C++ 代码实现了 “石头游戏” 问题的动态规划解决方案。通过一个一维动态规划数组 <code>dp</code> 来记录在不同的石头区间内先手玩家（Alex）与后手玩家（Lee）之间的最大分数差异。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">stoneGame</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length = piles.<span class="built_in">size</span>();  <span class="comment">// 获取石头堆的数量</span></span><br><span class="line">        <span class="keyword">auto</span> dp = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(length);  <span class="comment">// 初始化一个一维动态规划数组 dp，大小为 length</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 初始化 dp 数组，使得每个位置 dp[i] 代表在只有一堆石头时先手玩家能得到的分数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            dp[i] = piles[i];</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 逆序遍历石头堆，计算不同区间内先手玩家可以获得的最大分数差异</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">                <span class="comment">// dp[j] 表示从第 i 堆到第 j 堆石头时，先手玩家的最佳选择</span></span><br><span class="line">                dp[j] = <span class="built_in">max</span>(piles[i] - dp[j], piles[j] - dp[j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 如果 dp[length - 1] &gt; 0，说明先手玩家总能获得比后手玩家更多的石头</span></span><br><span class="line">        <span class="keyword">return</span> dp[length - <span class="number">1</span>] &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="逐行解释">逐行解释</h3><ol><li><p><strong><code>int length = piles.size();</code></strong>:</p><ul><li>获取石头堆的数量，并存储在 <code>length</code> 变量中。</li></ul></li><li><p><strong><code>auto dp = vector&lt;int&gt;(length);</code></strong>:</p><ul><li>初始化一个大小为 <code>length</code> 的一维动态规划数组 <code>dp</code>，用来存储从第 <code>i</code> 堆到第 <code>j</code> 堆石头时，先手玩家可以获得的最大分数差异。</li></ul></li><li><p><strong><code>for (int i = 0; i &lt; length; i++) &#123; dp[i] = piles[i]; &#125;</code></strong>:</p><ul><li>遍历 <code>piles</code> 数组，将每个位置 <code>i</code> 的石头数量 <code>piles[i]</code> 赋值给 <code>dp[i]</code>。这意味着在只有一个堆石头时，先手玩家能获得的分数就是这堆石头的数量。</li></ul></li><li><p><strong><code>for (int i = length - 2; i &gt;= 0; i--) &#123; ... &#125;</code></strong>:</p><ul><li>从倒数第二堆石头开始，逆序遍历 <code>piles</code> 数组，目的是计算在不同区间内先手玩家的最佳选择。</li></ul></li><li><p><strong><code>for (int j = i + 1; j &lt; length; j++) &#123; ... &#125;</code></strong>:</p><ul><li>遍历从 <code>i</code> 到 <code>j</code> 的石头堆，计算在这个区间内先手玩家能获得的最大分数差异。</li></ul></li><li><p><strong><code>dp[j] = max(piles[i] - dp[j], piles[j] - dp[j - 1]);</code></strong>:</p><ul><li>通过比较先手玩家在两种选择下能获得的最大分数差异来更新 <code>dp[j]</code>：<ul><li>选择拿走第 <code>i</code> 堆石头，剩余的区间为 <code>[i+1, j]</code>，此时后手玩家先手，分数差为 <code>piles[i] - dp[j]</code>。</li><li>选择拿走第 <code>j</code> 堆石头，剩余的区间为 <code>[i, j-1]</code>，此时后手玩家先手，分数差为 <code>piles[j] - dp[j - 1]</code>。</li></ul></li></ul></li><li><p><strong><code>return dp[length - 1] &gt; 0;</code></strong>:</p><ul><li>最后判断从第一堆到最后一堆石头的分数差 <code>dp[length - 1]</code> 是否大于 0。如果是，说明先手玩家可以确保自己获胜，返回 <code>true</code>。</li></ul></li></ol><h3 id="逻辑总结">逻辑总结</h3><ul><li>通过动态规划的方法，代码计算了从任意石头堆区间开始时，先手玩家与后手玩家的分数差异。</li><li>通过不断更新 <code>dp</code> 数组，最终确定从第一堆到最后一堆，先手玩家是否能始终保持分数领先。</li><li>该算法的时间复杂度为 <code>O(n^2)</code>，其中 <code>n</code> 是石堆的数量。因为双重循环的嵌套，每次计算的复杂度为常数。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目：   &lt;a href=&quot;https://leetcode.cn/problems/stone-game/description/&quot;&gt;877.石子游戏&lt;/a&gt;&lt;/h1&gt;
&lt;h2 id=&quot;题面&quot;&gt;题面&lt;/h2&gt;
&lt;p&gt;Alice 和 Bob 用几堆石子在做游戏。一共有偶</summary>
      
    
    
    
    <category term="Study" scheme="http://jasperfanger.github.io/categories/Study/"/>
    
    <category term="leetcode" scheme="http://jasperfanger.github.io/categories/Study/leetcode/"/>
    
    
    <category term="leetcode" scheme="http://jasperfanger.github.io/tags/leetcode/"/>
    
  </entry>
  
</feed>
